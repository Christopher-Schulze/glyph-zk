//! End-to-end proof generation and vector export for GLYPH.

use crate::ipa_bn254::{IPAParams, IPAProver};
use bytes::Bytes;
use ark_bn254::{Fr, G1Affine, G2Affine};
use ark_ec::{AffineRepr, CurveGroup};
use ark_ff::Field;
use ark_ff::PrimeField;
use hex;

/// Generate complete Solidity test file
pub fn generate_solidity_test_file() -> Result<String, String> {
    use crate::glyph_gkr::encode_artifact_poly_bound_packed_calldata_be;
    use crate::glyph_gkr::prove_packed_artifact_poly_sumcheck;

    let chain_id = 31337u64;
    let contract_addr = [0xeeu8; 20];
    let seed = b"glyph-real-proof-hash";

    let mut seed_input = Vec::with_capacity(seed.len() + 1);
    seed_input.extend_from_slice(seed);
    seed_input.push(0);
    let left = crate::adapters::keccak256(&seed_input);
    let last = seed_input.len() - 1;
    seed_input[last] = 1;
    let right = crate::adapters::keccak256(&seed_input);

    let ir = crate::adapter_ir::AdapterIr {
        version: 1,
        ops: vec![crate::adapter_ir::AdapterIrOp {
            kernel_id: crate::adapter_ir::kernel_id::HASH_SHA3_MERGE,
            args: Vec::new(),
        }],
    };
    let (commitment_tag, point_tag, claim128) =
        crate::adapter_ir::derive_glyph_artifact_from_hash_ir(
            &ir.encode(),
            &left,
            &right,
        )
        .map_err(|e| format!("hash merge artifact failed: {e}"))?;

    let claim = crate::glyph_gkr::gkr_canonicalize_u128(claim128);

    let rounds = 5usize;
    let proof = prove_packed_artifact_poly_sumcheck(
        &commitment_tag,
        &point_tag,
        &claim,
        chain_id,
        contract_addr,
        rounds,
    );
    let calldata = encode_artifact_poly_bound_packed_calldata_be(
        &proof,
        chain_id,
        contract_addr,
        &commitment_tag,
        &point_tag,
        &claim,
        true,
    );
    let proof_hex = hex::encode(&calldata);

    Ok(format!(
        r#"// SPDX-License-Identifier: MIT
// AUTO-GENERATED by GLYPH Rust Prover - DO NOT EDIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "./GLYPHVerifier.sol";

/**
 * @title GeneratedRealProofTest
 * @notice End-to-End tests with real packed calldata from the Rust prover.
 *
 * CRITICAL: These tests prove GLYPHVerifier actually verifies!
 * - Valid proofs: should return true
 * - Tampered proofs: should return false
 */
contract GeneratedRealProofTest is Test {{
    address internal constant TARGET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function setUp() public {{
        vm.chainId({chain_id});
        GLYPHVerifier impl = new GLYPHVerifier();
        vm.etch(TARGET, address(impl).code);
    }}

    function test_GLYPH_RealProof_HASH_Succeeds() public {{
        bytes memory proof = hex"{proof_hex}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_RealProof_HASH_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
}}
"#,
        chain_id = chain_id,
        proof_hex = proof_hex
    ))
}

fn decode_fixture_text(raw: &[u8]) -> Result<String, String> {
    if raw.starts_with(&[0xFF, 0xFE]) {
        let mut units = Vec::with_capacity((raw.len().saturating_sub(2)) / 2);
        for chunk in raw[2..].chunks(2) {
            if chunk.len() < 2 {
                break;
            }
            units.push(u16::from_le_bytes([chunk[0], chunk[1]]));
        }
        return String::from_utf16(&units).map_err(|e| format!("fixture utf16 decode failed: {e}"));
    }
    if raw.starts_with(&[0xFE, 0xFF]) {
        let mut units = Vec::with_capacity((raw.len().saturating_sub(2)) / 2);
        for chunk in raw[2..].chunks(2) {
            if chunk.len() < 2 {
                break;
            }
            units.push(u16::from_be_bytes([chunk[0], chunk[1]]));
        }
        return String::from_utf16(&units).map_err(|e| format!("fixture utf16 decode failed: {e}"));
    }
    String::from_utf8(raw.to_vec()).map_err(|e| format!("fixture utf8 decode failed: {e}"))
}

fn resolve_fixture_path(base: &str) -> &str {
    let candidate = format!("{}.candidate", base);
    if std::path::Path::new(&candidate).exists() {
        Box::leak(candidate.into_boxed_str())
    } else {
        base
    }
}

fn load_fixture_contents(path: &str) -> Result<String, String> {
    let raw = std::fs::read(path)
        .map_err(|e| format!("fixture file read failed for {path}: {e}"))?;
    decode_fixture_text(&raw)
}

fn parse_fixture_field<'a>(contents: &'a str, key: &str) -> Option<&'a str> {
    for line in contents.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }
        if let Some((k, v)) = line.split_once('=') {
            if k.trim() == key {
                return Some(v.trim());
            }
        }
    }
    None
}

fn load_upstream_receipt_fixture(
    path: &str,
) -> Result<crate::stark_winterfell::StarkUpstreamReceipt, String> {
    let contents = load_fixture_contents(path)?;
    let proof_hex = parse_fixture_field(&contents, "proof_hex")
        .ok_or_else(|| "proof_hex missing".to_string())?;
    let pub_inputs_hex = parse_fixture_field(&contents, "pub_inputs_hex")
        .ok_or_else(|| "pub_inputs_hex missing".to_string())?;
    let vk_params_hex = parse_fixture_field(&contents, "vk_params_hex")
        .ok_or_else(|| "vk_params_hex missing".to_string())?;
    let proof_bytes = hex::decode(proof_hex)
        .map_err(|e| format!("proof_hex decode failed: {e}"))?;
    let pub_inputs_bytes = hex::decode(pub_inputs_hex)
        .map_err(|e| format!("pub_inputs_hex decode failed: {e}"))?;
    let vk_params_bytes = hex::decode(vk_params_hex)
        .map_err(|e| format!("vk_params_hex decode failed: {e}"))?;
    Ok(crate::stark_winterfell::StarkUpstreamReceipt {
        proof_bytes,
        pub_inputs_bytes,
        vk_params_bytes,
    })
}

fn load_receipt_hex_bytes(path: &str) -> Result<Vec<u8>, String> {
    let contents = load_fixture_contents(path)?;
    let receipt_hex = parse_fixture_field(&contents, "receipt_hex")
        .ok_or_else(|| "receipt_hex missing".to_string())?;
    hex::decode(receipt_hex).map_err(|e| format!("receipt_hex decode failed: {e}"))
}

fn try_load_receipt_hex_bytes(path: &str) -> Result<Option<Vec<u8>>, String> {
    let contents = load_fixture_contents(path)?;
    let hex = match parse_fixture_field(&contents, "receipt_hex") {
        Some(hex) => hex,
        None => return Ok(None),
    };
    if hex.len() % 2 != 0 {
        return Ok(None);
    }
    hex::decode(hex)
        .map(Some)
        .map_err(|e| format!("receipt_hex decode failed: {e}"))
}

fn write_receipt_fixture(
    path: &str,
    receipt: &crate::stark_receipt::CanonicalStarkReceipt,
) -> Result<(), String> {
    if let Some(parent) = std::path::Path::new(path).parent() {
        std::fs::create_dir_all(parent)
            .map_err(|e| format!("create fixture dir failed: {e}"))?;
    }
    let hex = hex::encode(receipt.encode_for_hash());
    let payload = format!("receipt_hex={hex}\n");
    std::fs::write(path, payload)
        .map_err(|e| format!("write receipt fixture failed: {e}"))?;
    Ok(())
}

fn write_receipt_hex_fixture(path: &str, receipt_bytes: &[u8]) -> Result<(), String> {
    if let Some(parent) = std::path::Path::new(path).parent() {
        std::fs::create_dir_all(parent)
            .map_err(|e| format!("create fixture dir failed: {e}"))?;
    }
    let hex = hex::encode(receipt_bytes);
    let payload = format!("receipt_hex={hex}\n");
    std::fs::write(path, payload)
        .map_err(|e| format!("write receipt fixture failed: {e}"))?;
    Ok(())
}

fn load_fast_sha3_receipt_fixture() -> Result<crate::stark_winterfell::StarkUpstreamReceipt, String> {
    load_upstream_receipt_fixture("scripts/tools/fixtures/fast_sha3_receipt.txt")
}

fn load_fast_sha3_receipt_fixture_f64(
) -> Result<crate::stark_winterfell::StarkUpstreamReceipt, String> {
    load_upstream_receipt_fixture("scripts/tools/fixtures/fast_sha3_receipt_f64.txt")
}

fn load_fast_circle_receipt_fixture() -> Result<crate::stark_receipt::CanonicalStarkReceipt, String> {
    let candidate = "scripts/tools/fixtures/fast_circle_stark_receipt.txt.candidate";
    let path = "scripts/tools/fixtures/fast_circle_stark_receipt.txt";
    let bytes = if std::path::Path::new(candidate).exists() {
        try_load_receipt_hex_bytes(candidate)?
    } else if std::path::Path::new(path).exists() {
        try_load_receipt_hex_bytes(path)?
    } else {
        None
    };
    if let Some(bytes) = bytes {
        if let Some(receipt) = decode_and_verify_circle_receipt(&bytes) {
            return Ok(receipt);
        }
    }
    let receipt = build_circle_receipt_fixture_with_hash(
        crate::circle_stark::FIELD_M31_CIRCLE_ID,
        crate::circle_stark::HASH_SHA3_ID,
        b"circle_do_work_large:x^3+42,linear",
    )?;
    write_receipt_fixture(candidate, &receipt)?;
    Ok(receipt)
}

fn load_fast_circle_baby_bear_receipt_fixture(
) -> Result<crate::stark_receipt::CanonicalStarkReceipt, String> {
    let candidate = "scripts/tools/fixtures/fast_circle_stark_baby_bear_receipt.txt.candidate";
    let path = "scripts/tools/fixtures/fast_circle_stark_baby_bear_receipt.txt";
    let bytes = if std::path::Path::new(candidate).exists() {
        try_load_receipt_hex_bytes(candidate)?
    } else if std::path::Path::new(path).exists() {
        try_load_receipt_hex_bytes(path)?
    } else {
        None
    };
    if let Some(bytes) = bytes {
        if let Some(receipt) = decode_and_verify_circle_receipt(&bytes) {
            return Ok(receipt);
        }
    }
    let receipt = build_circle_receipt_fixture_with_hash(
        crate::circle_stark::FIELD_BABY_BEAR_CIRCLE_ID,
        crate::circle_stark::HASH_SHA3_ID,
        b"circle_do_work_large:x^3+42,linear",
    )?;
    write_receipt_fixture(candidate, &receipt)?;
    Ok(receipt)
}

fn build_standard_baby_bear_receipt_fixture(
) -> Result<crate::stark_receipt::CanonicalStarkReceipt, String> {
    use crate::standard_stark::{
        StandardConstraint,
        StandardStarkProfile,
        StandardStarkProgram,
        STANDARD_STARK_PROFILE_VERSION,
        STANDARD_STARK_PROGRAM_VERSION,
        FIELD_BABY_BEAR_STD_ID,
        HASH_SHA3_ID,
        VC_MERKLE_ID,
        CONSTRAINT_CUBE_PLUS_CONST,
        CONSTRAINT_LINEAR_MIX,
        build_standard_stark_receipt,
    };

    let profile = StandardStarkProfile {
        version: STANDARD_STARK_PROFILE_VERSION,
        log_domain_size: 3,
        num_queries: 2,
        blowup_factor: 1,
    };
    let program = StandardStarkProgram {
        version: STANDARD_STARK_PROGRAM_VERSION,
        field_id: FIELD_BABY_BEAR_STD_ID,
        hash_id: HASH_SHA3_ID,
        commitment_scheme_id: VC_MERKLE_ID,
        trace_width: 2,
        trace_length: 1u32 << profile.log_domain_size,
        constraints: vec![
            StandardConstraint {
                id: CONSTRAINT_CUBE_PLUS_CONST,
                col: 0,
                a: 0,
                b: 0,
                constant: 42,
            },
            StandardConstraint {
                id: CONSTRAINT_LINEAR_MIX,
                col: 1,
                a: 1,
                b: 0,
                constant: 7,
            },
        ],
        air_id: b"standard_do_work:x^3+42,linear".to_vec(),
    };
    build_standard_stark_receipt(&profile, &program, vec![7u32, 11u32])
        .map_err(|e| format!("standard baby bear receipt failed: {e}"))
}

fn build_standard_baby_bear_receipt_fixture_with_hash(
    hash_id: u8,
) -> Result<crate::stark_receipt::CanonicalStarkReceipt, String> {
    use crate::standard_stark::{
        StandardConstraint,
        StandardStarkProfile,
        StandardStarkProgram,
        STANDARD_STARK_PROFILE_VERSION,
        STANDARD_STARK_PROGRAM_VERSION,
        FIELD_BABY_BEAR_STD_ID,
        VC_MERKLE_ID,
        CONSTRAINT_CUBE_PLUS_CONST,
        CONSTRAINT_LINEAR_MIX,
        build_standard_stark_receipt,
    };

    let profile = StandardStarkProfile {
        version: STANDARD_STARK_PROFILE_VERSION,
        log_domain_size: 3,
        num_queries: 2,
        blowup_factor: 1,
    };
    let program = StandardStarkProgram {
        version: STANDARD_STARK_PROGRAM_VERSION,
        field_id: FIELD_BABY_BEAR_STD_ID,
        hash_id,
        commitment_scheme_id: VC_MERKLE_ID,
        trace_width: 2,
        trace_length: 1u32 << profile.log_domain_size,
        constraints: vec![
            StandardConstraint {
                id: CONSTRAINT_CUBE_PLUS_CONST,
                col: 0,
                a: 0,
                b: 0,
                constant: 42,
            },
            StandardConstraint {
                id: CONSTRAINT_LINEAR_MIX,
                col: 1,
                a: 1,
                b: 0,
                constant: 7,
            },
        ],
        air_id: b"standard_do_work:x^3+42,linear".to_vec(),
    };
    build_standard_stark_receipt(&profile, &program, vec![7u32, 11u32])
        .map_err(|e| format!("standard baby bear receipt failed: {e}"))
}

fn build_circle_receipt_fixture_with_hash(
    field_id: u8,
    hash_id: u8,
    air_id: &[u8],
) -> Result<crate::stark_receipt::CanonicalStarkReceipt, String> {
    use crate::circle_stark::{
        CircleConstraint,
        CircleStarkProfile,
        CircleStarkSimpleProgram,
        CIRCLE_STARK_PROFILE_VERSION,
        CIRCLE_STARK_SIMPLE_PROGRAM_VERSION,
        VC_MERKLE_ID,
        CONSTRAINT_CUBE_PLUS_CONST,
        CONSTRAINT_LINEAR_MIX,
        build_circle_stark_receipt,
    };

    let profile = CircleStarkProfile {
        version: CIRCLE_STARK_PROFILE_VERSION,
        log_domain_size: 3,
        num_queries: 2,
        blowup_factor: 1,
    };
    let program = CircleStarkSimpleProgram {
        version: CIRCLE_STARK_SIMPLE_PROGRAM_VERSION,
        field_id,
        hash_id,
        commitment_scheme_id: VC_MERKLE_ID,
        trace_width: 2,
        trace_length: 1u32 << profile.log_domain_size,
        constraints: vec![
            CircleConstraint {
                id: CONSTRAINT_CUBE_PLUS_CONST,
                col: 0,
                a: 0,
                b: 0,
                constant: 42,
            },
            CircleConstraint {
                id: CONSTRAINT_LINEAR_MIX,
                col: 1,
                a: 1,
                b: 0,
                constant: 7,
            },
        ],
        air_id: air_id.to_vec(),
    };
    build_circle_stark_receipt(&profile, &program, vec![7u32, 11u32])
        .map_err(|e| format!("circle receipt failed: {e}"))
}

fn build_circle_receipt_fixture_large(
) -> Result<crate::stark_receipt::CanonicalStarkReceipt, String> {
    use crate::circle_stark::{
        build_circle_stark_expr_receipt,
        CircleConstraintTerm,
        CircleExprConstraint,
        CircleStarkExprProgram,
        CircleStarkProfile,
        CIRCLE_STARK_EXPR_PROGRAM_VERSION,
        CIRCLE_STARK_PROFILE_VERSION,
        CONSTRAINT_LINEAR_COMBO,
        CONSTRAINT_MUL_ADD,
        FIELD_M31_CIRCLE_ID,
        HASH_SHA3_ID,
        VC_MERKLE_ID,
    };

    let profile = CircleStarkProfile {
        version: CIRCLE_STARK_PROFILE_VERSION,
        log_domain_size: 10,
        num_queries: 8,
        blowup_factor: 2,
    };
    let program = CircleStarkExprProgram {
        version: CIRCLE_STARK_EXPR_PROGRAM_VERSION,
        field_id: FIELD_M31_CIRCLE_ID,
        hash_id: HASH_SHA3_ID,
        commitment_scheme_id: VC_MERKLE_ID,
        trace_width: 4,
        trace_length: 1u32 << profile.log_domain_size,
        constraints: vec![
            CircleExprConstraint {
                id: CONSTRAINT_LINEAR_COMBO,
                out_col: 0,
                out_is_next: 1,
                a: 0,
                a_is_next: 0,
                b: 0,
                b_is_next: 0,
                constant: 7,
                terms: vec![
                    CircleConstraintTerm {
                        col: 0,
                        coeff: 3,
                        is_next: 0,
                    },
                    CircleConstraintTerm {
                        col: 1,
                        coeff: 5,
                        is_next: 0,
                    },
                ],
            },
            CircleExprConstraint {
                id: CONSTRAINT_MUL_ADD,
                out_col: 1,
                out_is_next: 1,
                a: 0,
                a_is_next: 0,
                b: 2,
                b_is_next: 0,
                constant: 9,
                terms: vec![CircleConstraintTerm {
                    col: 1,
                    coeff: 11,
                    is_next: 0,
                }],
            },
            CircleExprConstraint {
                id: CONSTRAINT_LINEAR_COMBO,
                out_col: 2,
                out_is_next: 1,
                a: 0,
                a_is_next: 0,
                b: 0,
                b_is_next: 0,
                constant: 3,
                terms: vec![
                    CircleConstraintTerm {
                        col: 0,
                        coeff: 2,
                        is_next: 0,
                    },
                    CircleConstraintTerm {
                        col: 2,
                        coeff: 7,
                        is_next: 0,
                    },
                    CircleConstraintTerm {
                        col: 3,
                        coeff: 13,
                        is_next: 0,
                    },
                ],
            },
            CircleExprConstraint {
                id: CONSTRAINT_MUL_ADD,
                out_col: 3,
                out_is_next: 1,
                a: 1,
                a_is_next: 0,
                b: 3,
                b_is_next: 0,
                constant: 5,
                terms: vec![CircleConstraintTerm {
                    col: 0,
                    coeff: 17,
                    is_next: 0,
                }],
            },
        ],
        air_id: b"circle_do_work:linear+mul".to_vec(),
    };
    let start_row = vec![7u32, 11u32, 5u32, 9u32];
    build_circle_stark_expr_receipt(&profile, &program, start_row)
        .map_err(|e| format!("circle receipt failed: {e}"))
}

fn decode_and_verify_circle_receipt(
    bytes: &[u8],
) -> Option<crate::stark_receipt::CanonicalStarkReceipt> {
    let receipt = crate::stark_receipt::CanonicalStarkReceipt::decode(bytes).ok()?;
    let vk = crate::stark_receipt::CanonicalStarkReceipt::decode_and_validate_vk(&receipt).ok()?;
    let program = crate::circle_stark::decode_circle_stark_program(&vk.program_bytes).ok()?;
    if crate::circle_stark::verify_circle_stark_receipt(&receipt, &vk, &program).is_ok() {
        Some(receipt)
    } else {
        None
    }
}

fn load_fast_circle_koala_bear_receipt_fixture(
) -> Result<crate::stark_receipt::CanonicalStarkReceipt, String> {
    let candidate = "scripts/tools/fixtures/fast_circle_stark_koala_bear_receipt.txt.candidate";
    let path = "scripts/tools/fixtures/fast_circle_stark_koala_bear_receipt.txt";
    let bytes = if std::path::Path::new(candidate).exists() {
        try_load_receipt_hex_bytes(candidate)?
    } else if std::path::Path::new(path).exists() {
        try_load_receipt_hex_bytes(path)?
    } else {
        None
    };
    if let Some(bytes) = bytes {
        if let Some(receipt) = decode_and_verify_circle_receipt(&bytes) {
            return Ok(receipt);
        }
    }
    let receipt = build_circle_receipt_fixture_with_hash(
        crate::circle_stark::FIELD_KOALA_BEAR_CIRCLE_ID,
        crate::circle_stark::HASH_SHA3_ID,
        b"circle_do_work_large:x^3+42,linear",
    )?;
    write_receipt_fixture(candidate, &receipt)?;
    Ok(receipt)
}

fn load_fast_plonky2_goldilocks_receipt_fixture(
) -> Result<crate::plonky2_receipt::CanonicalPlonky2Receipt, String> {
    let path = resolve_fixture_path("scripts/tools/fixtures/fast_plonky2_goldilocks_receipt.txt");
    let bytes = load_receipt_hex_bytes(path)?;
    crate::plonky2_receipt::decode_plonky2_receipt(&bytes)
        .map_err(|e| format!("plonky2 receipt decode failed: {e}"))
}

fn build_plonky3_profile(hash_params_bytes: Vec<u8>) -> crate::plonky3_stark::Plonky3StarkProfile {
    crate::plonky3_stark::Plonky3StarkProfile {
        version: crate::plonky3_stark::PLONKY3_STARK_PROFILE_VERSION,
        pcs_type: crate::plonky3_stark::PLONKY3_PCS_FRI_ID,
        log_blowup: 2,
        log_final_poly_len: 0,
        num_queries: 2,
        commit_pow_bits: 0,
        query_pow_bits: 0,
        num_random_codewords: 0,
        hash_params_bytes,
    }
}

fn build_plonky3_program(
    field_id: u8,
    hash_id: u8,
    air_id: u8,
) -> crate::plonky3_stark::Plonky3StarkProgram {
    crate::plonky3_stark::Plonky3StarkProgram {
        version: crate::plonky3_stark::PLONKY3_STARK_PROGRAM_VERSION,
        field_id,
        hash_id,
        commitment_scheme_id: crate::plonky3_stark::VC_MERKLE_ID,
        air_id,
        air_params_bytes: Vec::new(),
    }
}

fn load_or_build_plonky3_receipt_fixture(
    path: &str,
    profile: crate::plonky3_stark::Plonky3StarkProfile,
    program: crate::plonky3_stark::Plonky3StarkProgram,
) -> Result<crate::stark_receipt::CanonicalStarkReceipt, String> {
    let candidate = format!("{path}.candidate");
    let bytes = if std::path::Path::new(&candidate).exists() {
        try_load_receipt_hex_bytes(&candidate)?
    } else if std::path::Path::new(path).exists() {
        try_load_receipt_hex_bytes(path)?
    } else {
        None
    };
    let bytes = match bytes {
        Some(bytes) => bytes,
        None => {
            let receipt =
                crate::plonky3_stark::build_plonky3_receipt(&profile, &program)
                    .map_err(|e| format!("plonky3 receipt build failed: {e}"))?;
            write_receipt_fixture(&candidate, &receipt)?;
            load_receipt_hex_bytes(&candidate)?
        }
    };
    crate::stark_receipt::CanonicalStarkReceipt::decode(&bytes)
        .map_err(|e| format!("plonky3 receipt decode failed: {e}"))
}

fn load_or_build_miden_receipt_fixture(
    path: &str,
    hash_fn: miden_prover::HashFunction,
) -> Result<crate::stark_receipt::CanonicalStarkReceipt, String> {
    let candidate = format!("{path}.candidate");
    let resolved = if std::path::Path::new(&candidate).exists() {
        candidate
    } else if std::path::Path::new(path).exists() {
        path.to_string()
    } else {
        let receipt = build_miden_receipt_fixture(hash_fn)?;
        write_receipt_fixture(&candidate, &receipt)?;
        write_receipt_fixture(path, &receipt)?;
        path.to_string()
    };
    let bytes = load_receipt_hex_bytes(&resolved)?;
    crate::stark_receipt::CanonicalStarkReceipt::decode(&bytes)
        .map_err(|e| format!("miden receipt decode failed: {e}"))
}

fn load_plonk_bn254_gnark_receipt_fixture() -> Result<Option<Vec<u8>>, String> {
    let candidate = "scripts/tools/fixtures/plonk_bn254_gnark_receipt.txt.candidate";
    let path = if std::path::Path::new(candidate).exists() {
        candidate
    } else {
        "scripts/tools/fixtures/plonk_bn254_gnark_receipt.txt"
    };
    let path = resolve_fixture_path(path);
    if !std::path::Path::new(path).exists() {
        return Ok(None);
    }
    let contents = load_fixture_contents(path)?;
    let vk_hex = parse_fixture_field(&contents, "vk_hex")
        .ok_or_else(|| "vk_hex missing".to_string())?;
    let proof_hex = parse_fixture_field(&contents, "proof_hex")
        .ok_or_else(|| "proof_hex missing".to_string())?;
    let pub_hex = parse_fixture_field(&contents, "pub_inputs_hex")
        .ok_or_else(|| "pub_inputs_hex missing".to_string())?;
    let vk_bytes = hex::decode(vk_hex).map_err(|e| format!("vk_hex decode failed: {e}"))?;
    let proof_bytes = hex::decode(proof_hex).map_err(|e| format!("proof_hex decode failed: {e}"))?;
    let public_inputs_bytes =
        hex::decode(pub_hex).map_err(|e| format!("pub_inputs_hex decode failed: {e}"))?;
    let receipt = crate::plonk_adapter::PlonkReceipt {
        backend_id: crate::plonk_adapter::PLONK_BACKEND_GNARK,
        curve_id: crate::plonk_adapter::PLONK_CURVE_BN254,
        encoding_id: crate::plonk_adapter::PLONK_ENCODING_BN254_BE,
        pcs_id: crate::plonk_adapter::PLONK_PCS_KZG,
        protocol_id: crate::plonk_adapter::PLONK_PROTOCOL_PLONK,
        transcript_id: crate::plonk_adapter::PLONK_TRANSCRIPT_NATIVE,
        backend_params_bytes: Vec::new(),
        vk_bytes,
        public_inputs_bytes,
        proof_bytes,
    };
    Ok(Some(crate::plonk_adapter::encode_plonk_receipt(&receipt)))
}

fn load_or_build_halo2_receipt_fixture(
    path: &str,
    builder: impl FnOnce() -> Result<Vec<u8>, String>,
) -> Result<Vec<u8>, String> {
    let path = resolve_fixture_path(path);
    if std::path::Path::new(path).exists() {
        if let Some(receipt_bytes) = try_load_receipt_hex_bytes(path)? {
            if crate::halo2_receipt::verify_halo2_receipt(&receipt_bytes).is_ok() {
                return Ok(receipt_bytes);
            }
        }
    }
    let receipt_bytes = builder()?;
    let candidate = format!("{path}.candidate");
    write_receipt_hex_fixture(&candidate, &receipt_bytes)?;
    Ok(receipt_bytes)
}

fn build_halo2_kzg_receipt_bn256() -> Result<Vec<u8>, String> {
    use crate::halo2_receipt::{
        encode_halo2_instances, encode_halo2_receipt, verify_halo2_receipt, Halo2Receipt,
        StandardPlonkCircuit, HALO2_BACKEND_KZG_GWC, HALO2_CIRCUIT_STANDARD_PLONK,
        HALO2_CURVE_BN256, HALO2_TRANSCRIPT_BLAKE2B,
    };
    use halo2_proofs::plonk::{create_proof, keygen_pk, keygen_vk_custom};
    use halo2_proofs::poly::kzg::commitment::{KZGCommitmentScheme, ParamsKZG};
    use halo2_proofs::poly::kzg::multiopen::ProverGWC;
    use halo2_proofs::transcript::{Blake2bWrite, Challenge255, TranscriptWriterBuffer};
    use halo2_proofs::SerdeFormat;
    use halo2_proofs::halo2curves::bn256::{Bn256, Fr as Bn256Fr, G1Affine as Bn256G1Affine};
    use rand::rngs::StdRng;
    use rand::SeedableRng;

    let k = 4u32;
    let mut rng = StdRng::seed_from_u64(0x1234_5678);
    let circuit = StandardPlonkCircuit::<Bn256Fr>(Bn256Fr::from(7u64));
    let params = ParamsKZG::<Bn256>::setup(k, &mut rng);
    let compress_selectors = true;
    let vk = keygen_vk_custom(&params, &circuit, compress_selectors)
        .map_err(|e| format!("halo2 vk failed: {e}"))?;
    let pk = keygen_pk(&params, vk.clone(), &circuit)
        .map_err(|e| format!("halo2 pk failed: {e}"))?;

    let instances: Vec<Vec<Vec<Bn256Fr>>> = vec![vec![vec![circuit.0]]];
    let mut transcript =
        Blake2bWrite::<_, _, Challenge255<Bn256G1Affine>>::init(Vec::new());
    create_proof::<
        KZGCommitmentScheme<Bn256>,
        ProverGWC<'_, Bn256>,
        Challenge255<Bn256G1Affine>,
        _,
        Blake2bWrite<Vec<u8>, Bn256G1Affine, Challenge255<Bn256G1Affine>>,
        _,
    >(
        &params,
        &pk,
        &[circuit],
        instances.as_slice(),
        &mut rng,
        &mut transcript,
    )
    .map_err(|e| format!("halo2 proof failed: {e}"))?;
    let proof_bytes = transcript.finalize();

    let mut params_bytes = Vec::new();
    params
        .verifier_params()
        .write_custom(&mut params_bytes, SerdeFormat::RawBytes)
        .map_err(|e| format!("halo2 params write failed: {e}"))?;
    let mut vk_bytes = Vec::new();
    vk.write(&mut vk_bytes, SerdeFormat::RawBytes)
        .map_err(|e| format!("halo2 vk write failed: {e}"))?;
    let instances_bytes = encode_halo2_instances(&instances[0])
        .map_err(|e| format!("halo2 instances encode failed: {e}"))?;

    let receipt = Halo2Receipt {
        curve_id: HALO2_CURVE_BN256,
        backend_id: HALO2_BACKEND_KZG_GWC,
        transcript_id: HALO2_TRANSCRIPT_BLAKE2B,
        circuit_id: HALO2_CIRCUIT_STANDARD_PLONK,
        compress_selectors,
        circuit_params_bytes: Vec::new(),
        params_bytes,
        vk_bytes,
        instances_bytes,
        proof_bytes,
    };
    let receipt_bytes = encode_halo2_receipt(&receipt);
    verify_halo2_receipt(&receipt_bytes)
        .map_err(|e| format!("halo2 bn256 verify failed: {e}"))?;
    Ok(receipt_bytes)
}

fn build_halo2_kzg_receipt_bls12381() -> Result<Vec<u8>, String> {
    use crate::halo2_receipt::{
        encode_halo2_instances, encode_halo2_receipt, verify_halo2_receipt, Halo2Receipt,
        StandardPlonkCircuit, HALO2_BACKEND_KZG_GWC, HALO2_CIRCUIT_STANDARD_PLONK,
        HALO2_CURVE_BLS12381, HALO2_TRANSCRIPT_BLAKE2B,
    };
    use halo2_proofs::plonk::{create_proof, keygen_pk, keygen_vk_custom};
    use halo2_proofs::poly::kzg::commitment::{KZGCommitmentScheme, ParamsKZG};
    use halo2_proofs::poly::kzg::multiopen::ProverGWC;
    use halo2_proofs::transcript::{Blake2bWrite, Challenge255, TranscriptWriterBuffer};
    use halo2_proofs::SerdeFormat;
    use halo2_proofs::halo2curves::bls12381::{
        Bls12381,
        Fr as Bls12381Fr,
        G1Affine as Bls12381G1Affine,
    };
    use rand::rngs::StdRng;
    use rand::SeedableRng;

    let k = 4u32;
    let mut rng = StdRng::seed_from_u64(0x9abc_def0);
    let circuit = StandardPlonkCircuit::<Bls12381Fr>(Bls12381Fr::from(7u64));
    let params = ParamsKZG::<Bls12381>::setup(k, &mut rng);
    let compress_selectors = true;
    let vk = keygen_vk_custom(&params, &circuit, compress_selectors)
        .map_err(|e| format!("halo2 vk failed: {e}"))?;
    let pk = keygen_pk(&params, vk.clone(), &circuit)
        .map_err(|e| format!("halo2 pk failed: {e}"))?;

    let instances: Vec<Vec<Vec<Bls12381Fr>>> = vec![vec![vec![circuit.0]]];
    let mut transcript =
        Blake2bWrite::<_, _, Challenge255<Bls12381G1Affine>>::init(Vec::new());
    create_proof::<
        KZGCommitmentScheme<Bls12381>,
        ProverGWC<'_, Bls12381>,
        Challenge255<Bls12381G1Affine>,
        _,
        Blake2bWrite<Vec<u8>, Bls12381G1Affine, Challenge255<Bls12381G1Affine>>,
        _,
    >(
        &params,
        &pk,
        &[circuit],
        instances.as_slice(),
        &mut rng,
        &mut transcript,
    )
    .map_err(|e| format!("halo2 proof failed: {e}"))?;
    let proof_bytes = transcript.finalize();

    let mut params_bytes = Vec::new();
    params
        .verifier_params()
        .write_custom(&mut params_bytes, SerdeFormat::RawBytes)
        .map_err(|e| format!("halo2 params write failed: {e}"))?;
    let mut vk_bytes = Vec::new();
    vk.write(&mut vk_bytes, SerdeFormat::RawBytes)
        .map_err(|e| format!("halo2 vk write failed: {e}"))?;
    let instances_bytes = encode_halo2_instances(&instances[0])
        .map_err(|e| format!("halo2 instances encode failed: {e}"))?;

    let receipt = Halo2Receipt {
        curve_id: HALO2_CURVE_BLS12381,
        backend_id: HALO2_BACKEND_KZG_GWC,
        transcript_id: HALO2_TRANSCRIPT_BLAKE2B,
        circuit_id: HALO2_CIRCUIT_STANDARD_PLONK,
        compress_selectors,
        circuit_params_bytes: Vec::new(),
        params_bytes,
        vk_bytes,
        instances_bytes,
        proof_bytes,
    };
    let receipt_bytes = encode_halo2_receipt(&receipt);
    verify_halo2_receipt(&receipt_bytes)
        .map_err(|e| format!("halo2 bls12381 verify failed: {e}"))?;
    Ok(receipt_bytes)
}

fn load_or_build_plonk_bls_receipt_fixture(path: &str) -> Result<Vec<u8>, String> {
    let path = resolve_fixture_path(path);
    if std::path::Path::new(path).exists() {
        let receipt_bytes = load_receipt_hex_bytes(path)?;
        if crate::plonk_adapter::verify_plonk_receipt(&receipt_bytes).is_ok() {
            return Ok(receipt_bytes);
        }
    }

    let receipt_bytes = build_plonk_bls_receipt_fixture()?;
    let candidate = format!("{}.candidate", path);
    write_receipt_hex_fixture(&candidate, &receipt_bytes)?;
    Ok(receipt_bytes)
}

fn build_plonk_bls_receipt_fixture() -> Result<Vec<u8>, String> {
    use dusk_plonk::prelude::*;
    use dusk_bytes::Serializable;
    use rand::rngs::StdRng;
    use rand::SeedableRng;

    #[derive(Clone)]
    struct EqCircuit {
        left: BlsScalar,
        right: BlsScalar,
    }

    impl Default for EqCircuit {
        fn default() -> Self {
            Self {
                left: BlsScalar::zero(),
                right: BlsScalar::zero(),
            }
        }
    }

    impl Circuit for EqCircuit {
        fn circuit(&self, composer: &mut Composer) -> Result<(), Error> {
            let left = composer.append_witness(self.left);
            let right = composer.append_witness(self.right);
            composer.assert_equal(left, right);
            Ok(())
        }
    }

    let label = b"glyph-plonk-bls";
    let mut rng = StdRng::seed_from_u64(0x4759_2a1b_9c4d_0f11);
    let pp = PublicParameters::setup(1 << 8, &mut rng)
        .map_err(|e| format!("plonk pp failed: {e:?}"))?;
    let (prover, verifier) = Compiler::compile::<EqCircuit>(&pp, label)
        .map_err(|e| format!("plonk compile failed: {e:?}"))?;
    let circuit = EqCircuit {
        left: BlsScalar::one(),
        right: BlsScalar::one(),
    };
    let (proof, public_inputs) = prover
        .prove(&mut rng, &circuit)
        .map_err(|e| format!("plonk prove failed: {e:?}"))?;
    verifier
        .verify(&proof, &public_inputs)
        .map_err(|e| format!("plonk verify failed: {e:?}"))?;

    let mut public_inputs_bytes = Vec::with_capacity(public_inputs.len() * 32);
    for value in public_inputs {
        public_inputs_bytes.extend_from_slice(&value.to_bytes());
    }

    let receipt = crate::plonk_adapter::PlonkReceipt {
        backend_id: crate::plonk_adapter::PLONK_BACKEND_DUSK,
        curve_id: crate::plonk_adapter::PLONK_CURVE_BLS12381,
        encoding_id: crate::plonk_adapter::PLONK_ENCODING_BLS_LE,
        pcs_id: crate::plonk_adapter::PLONK_PCS_KZG,
        protocol_id: crate::plonk_adapter::PLONK_PROTOCOL_PLONK,
        transcript_id: crate::plonk_adapter::PLONK_TRANSCRIPT_NATIVE,
        backend_params_bytes: Vec::new(),
        vk_bytes: verifier.to_bytes(),
        public_inputs_bytes,
        proof_bytes: proof.to_bytes().to_vec(),
    };
    let encoded = crate::plonk_adapter::encode_plonk_receipt(&receipt);
    crate::plonk_adapter::verify_plonk_receipt(&encoded)
        .map_err(|e| format!("plonk receipt verify failed: {e}"))?;
    Ok(encoded)
}

fn load_or_build_cairo_receipt_fixture(
    path: &str,
    layout_id: u8,
    hasher_id: u8,
    stone_version: u8,
    verifier_type: u8,
) -> Result<crate::stark_receipt::CanonicalStarkReceipt, String> {
    let path = resolve_fixture_path(path);
    let proof_json = std::fs::read_to_string(path)
        .map_err(|e| format!("cairo proof json missing: {e}"))?;
    let (receipt, program) = crate::cairo_stark::parse_cairo_receipt_from_json(
        &proof_json,
        layout_id,
        hasher_id,
        stone_version,
        verifier_type,
    )
    .map_err(|e| format!("cairo receipt parse failed: {e}"))?;
    let decoded_vk = crate::stark_receipt::CanonicalStarkReceipt::decode_and_validate_vk(&receipt)
        .map_err(|e| format!("cairo vk decode failed: {e}"))?;
    let decoded_program =
        crate::cairo_stark::decode_cairo_program(&decoded_vk.program_bytes)
            .map_err(|e| format!("cairo program decode failed: {e}"))?;
    crate::cairo_stark::verify_cairo_receipt(&receipt, &decoded_vk, &decoded_program)
        .map_err(|e| format!("cairo receipt verify failed: {e}"))?;
    if decoded_program != program {
        return Err("cairo program mismatch after decode".to_string());
    }
    Ok(receipt)
}

fn build_miden_receipt_fixture(
    hash_fn: miden_prover::HashFunction,
) -> Result<crate::stark_receipt::CanonicalStarkReceipt, String> {
    use miden_assembly::{Assembler, DefaultSourceManager};
    use miden_prover::{AdviceInputs, ProvingOptions, StackInputs};
    use miden_processor::DefaultHost;
    use std::sync::Arc;
    use winter_utils::Serializable;

    let program_source = r#"
        begin
            add
        end
    "#;
    let source_manager = Arc::new(DefaultSourceManager::default());
    let program = Assembler::new(source_manager)
        .assemble_program(program_source)
        .map_err(|e| format!("assemble miden program failed: {e}"))?;

    let stack_inputs = StackInputs::try_from_ints([3u64, 5u64])
        .map_err(|e| format!("stack inputs failed: {e}"))?;
    let advice_inputs = AdviceInputs::default();
    let mut host = DefaultHost::default();
    let options = ProvingOptions::with_128_bit_security(hash_fn);
    let (stack_outputs, proof) =
        miden_prover::prove(&program, stack_inputs.clone(), advice_inputs, &mut host, options)
            .map_err(|e| format!("miden prove failed: {e}"))?;

    let program_info = miden_verifier::ProgramInfo::from(program);
    let program_bytes = program_info.to_bytes();
    let stack_inputs_bytes = stack_inputs.to_bytes();
    let stack_outputs_bytes = stack_outputs.to_bytes();
    let proof_bytes = proof.to_bytes();
    let hash_id = crate::miden_stark::miden_hash_fn_to_id(hash_fn);

    let program = crate::miden_stark::MidenStarkProgram {
        version: crate::miden_stark::MIDEN_STARK_PROGRAM_VERSION,
        field_id: crate::miden_stark::FIELD_MIDEN_GOLDILOCKS_ID,
        hash_id,
        commitment_scheme_id: crate::miden_stark::VC_MERKLE_ID,
        program_info_bytes: program_bytes,
    };
    let pub_inputs = crate::miden_stark::MidenPublicInputs {
        stack_inputs_bytes,
        stack_outputs_bytes,
    };
    let vk = crate::stark_receipt::CanonicalStarkVk {
        version: 1,
        field_id: program.field_id,
        hash_id: program.hash_id,
        commitment_scheme_id: program.commitment_scheme_id,
        consts_bytes: Vec::new(),
        program_bytes: program.encode(),
    };
    let receipt = crate::stark_receipt::CanonicalStarkReceipt {
        proof_bytes,
        pub_inputs_bytes: pub_inputs.encode(),
        vk_bytes: vk.encode(),
    };

    let decoded_vk = crate::stark_receipt::CanonicalStarkReceipt::decode_and_validate_vk(&receipt)
        .map_err(|e| format!("miden vk decode failed: {e}"))?;
    let decoded_program =
        crate::miden_stark::decode_miden_program(&decoded_vk.program_bytes)
            .map_err(|e| format!("miden program decode failed: {e}"))?;
    crate::miden_stark::verify_miden_receipt(&receipt, &decoded_vk, &decoded_program)
        .map_err(|e| format!("miden receipt verify failed: {e}"))?;
    Ok(receipt)
}

fn load_fast_groth16_bls12381_receipt_fixture() -> Result<Vec<u8>, String> {
    let path = resolve_fixture_path("scripts/tools/fixtures/groth16_bls12381_receipt.txt");
    load_receipt_hex_bytes(path)
}

fn load_fast_kzg_bls12381_receipt_fixture() -> Result<Vec<u8>, String> {
    let path = resolve_fixture_path("scripts/tools/fixtures/kzg_bls12381_receipt.txt");
    load_receipt_hex_bytes(path)
}

fn load_sp1_receipt_fixture(path: &str) -> Result<Option<Vec<u8>>, String> {
    let path = resolve_fixture_path(path);
    if std::path::Path::new(path).exists() {
        Ok(Some(load_receipt_hex_bytes(path)?))
    } else {
        Ok(None)
    }
}

fn load_fast_circle_receipt_fixture_large(
) -> Result<crate::stark_receipt::CanonicalStarkReceipt, String> {
    let candidate = "scripts/tools/fixtures/fast_circle_stark_receipt_large.txt.candidate";
    let path = "scripts/tools/fixtures/fast_circle_stark_receipt_large.txt";
    let bytes = if std::path::Path::new(candidate).exists() {
        try_load_receipt_hex_bytes(candidate)?
    } else if std::path::Path::new(path).exists() {
        try_load_receipt_hex_bytes(path)?
    } else {
        None
    };
    if let Some(bytes) = bytes {
        if let Some(receipt) = decode_and_verify_circle_receipt(&bytes) {
            return Ok(receipt);
        }
    }
    let receipt = build_circle_receipt_fixture_large()?;
    write_receipt_fixture(candidate, &receipt)?;
    Ok(receipt)
}

pub fn generate_glyph_stark_solidity_test_file() -> Result<String, String> {
    use crate::glyph_gkr::encode_artifact_poly_bound_packed_calldata_be;
    use crate::glyph_gkr::prove_packed_artifact_poly_sumcheck;

    let chain_id = 31337u64;
    let contract_addr = [0xeeu8; 20];
    let rounds = 3usize;
    let include_f64 = std::env::var("GLYPH_E2E_INCLUDE_F64")
        .ok()
        .map(|v| v == "1" || v.eq_ignore_ascii_case("true"))
        .unwrap_or(false);
    let include_circle_large = std::env::var("GLYPH_E2E_INCLUDE_CIRCLE_LARGE")
        .ok()
        .map(|v| v == "1" || v.eq_ignore_ascii_case("true"))
        .unwrap_or(false);
    let include_plonky2 = std::env::var("GLYPH_E2E_INCLUDE_PLONKY2")
        .ok()
        .map(|v| v == "1" || v.eq_ignore_ascii_case("true"))
        .unwrap_or(false);
    let include_plonky3 = std::env::var("GLYPH_E2E_INCLUDE_PLONKY3")
        .ok()
        .map(|v| v != "0" && !v.eq_ignore_ascii_case("false"))
        .unwrap_or(true);
    let include_miden = std::env::var("GLYPH_E2E_INCLUDE_MIDEN")
        .ok()
        .map(|v| v != "0" && !v.eq_ignore_ascii_case("false"))
        .unwrap_or(true);
    let include_cairo = std::env::var("GLYPH_E2E_INCLUDE_CAIRO")
        .ok()
        .map(|v| v != "0" && !v.eq_ignore_ascii_case("false"))
        .unwrap_or(true);

    let make_stark_calldata_hex = |seed: &[u8],
                                   canonical: Vec<crate::stark_receipt::CanonicalStarkReceipt>|
     -> Result<String, String> {
        let (commitment_tag, point_tag, claim128) =
            crate::stark_adapter::verified_canonical_stark_receipts_to_glyph_artifact(
                seed,
                &canonical,
            )
            .map_err(|e| format!("canonical receipts must verify: {e}"))?;
        let claim = crate::glyph_gkr::gkr_canonicalize_u128(claim128);
        let proof = prove_packed_artifact_poly_sumcheck(
            &commitment_tag,
            &point_tag,
            &claim,
            chain_id,
            contract_addr,
            rounds,
        );
        let calldata = encode_artifact_poly_bound_packed_calldata_be(
            &proof,
            chain_id,
            contract_addr,
            &commitment_tag,
            &point_tag,
            &claim,
            false,
        );
        Ok(hex::encode(&calldata))
    };

    let seed_f128 = b"glyph-option-d-stark-gkr";
    let receipt_f128 = load_fast_sha3_receipt_fixture()?;
    let canonical_f128: Vec<crate::stark_receipt::CanonicalStarkReceipt> = vec![
        crate::stark_winterfell::canonical_stark_receipt_from_upstream_do_work(&receipt_f128)
            .map_err(|e| format!("receipt failed: {e}"))?,
    ];

    let (commitment_tag_f128, point_tag_f128, claim128_f128) =
        crate::stark_adapter::verified_canonical_stark_receipts_to_glyph_artifact(
            seed_f128,
            &canonical_f128,
        )
        .map_err(|e| format!("canonical receipts must verify: {e}"))?;
    let claim_f128 = crate::glyph_gkr::gkr_canonicalize_u128(claim128_f128);

    let proof_f128 = prove_packed_artifact_poly_sumcheck(
        &commitment_tag_f128,
        &point_tag_f128,
        &claim_f128,
        chain_id,
        contract_addr,
        rounds,
    );
    let calldata_f128 = encode_artifact_poly_bound_packed_calldata_be(
        &proof_f128,
        chain_id,
        contract_addr,
        &commitment_tag_f128,
        &point_tag_f128,
        &claim_f128,
        false,
    );
    let proof_hex_f128 = hex::encode(&calldata_f128);

    let f64_tests: Result<String, String> = if include_f64 {
        let seed_f64 = b"glyph-option-d-stark-gkr-f64";
        let receipt_f64 = load_fast_sha3_receipt_fixture_f64()?;
        let canonical_f64: Vec<crate::stark_receipt::CanonicalStarkReceipt> = vec![
            crate::stark_winterfell_f64::canonical_stark_receipt_from_upstream_do_work(&receipt_f64)
                .map_err(|e| format!("receipt failed: {e}"))?,
        ];

        let (commitment_tag_f64, point_tag_f64, claim128_f64) =
            crate::stark_adapter::verified_canonical_stark_receipts_to_glyph_artifact(
                seed_f64,
                &canonical_f64,
            )
            .map_err(|e| format!("canonical receipts must verify: {e}"))?;
        let claim_f64 = crate::glyph_gkr::gkr_canonicalize_u128(claim128_f64);

        let proof_f64 = prove_packed_artifact_poly_sumcheck(
            &commitment_tag_f64,
            &point_tag_f64,
            &claim_f64,
            chain_id,
            contract_addr,
            rounds,
        );
        let calldata_f64 = encode_artifact_poly_bound_packed_calldata_be(
            &proof_f64,
            chain_id,
            contract_addr,
            &commitment_tag_f64,
            &point_tag_f64,
            &claim_f64,
            false,
        );
        let proof_hex_f64 = hex::encode(&calldata_f64);
        Ok(format!(
            r#"
    function test_GLYPH_STARK_F64_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_f64}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_F64_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_f64}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
        ))
    } else {
        Ok(String::new())
    };

    let goldilocks_tests: Result<String, String> = if include_plonky2 {
        let seed_goldilocks = b"glyph-option-d-stark-gkr-goldilocks";
        let receipt_goldilocks = load_fast_plonky2_goldilocks_receipt_fixture()?;
        let canonical_goldilocks: Vec<crate::stark_receipt::CanonicalStarkReceipt> =
            vec![receipt_goldilocks.to_canonical_receipt()];
        let (commitment_tag_goldilocks, point_tag_goldilocks, claim128_goldilocks) =
            crate::stark_adapter::verified_canonical_stark_receipts_to_glyph_artifact(
                seed_goldilocks,
                &canonical_goldilocks,
            )
            .map_err(|e| format!("goldilocks receipt must verify: {e}"))?;
        let claim_goldilocks = crate::glyph_gkr::gkr_canonicalize_u128(claim128_goldilocks);

        let proof_goldilocks = prove_packed_artifact_poly_sumcheck(
            &commitment_tag_goldilocks,
            &point_tag_goldilocks,
            &claim_goldilocks,
            chain_id,
            contract_addr,
            rounds,
        );
        let calldata_goldilocks = encode_artifact_poly_bound_packed_calldata_be(
            &proof_goldilocks,
            chain_id,
            contract_addr,
            &commitment_tag_goldilocks,
            &point_tag_goldilocks,
            &claim_goldilocks,
            false,
        );
        let proof_hex_goldilocks = hex::encode(&calldata_goldilocks);
        Ok(format!(
            r#"
    function test_GLYPH_STARK_Goldilocks_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_goldilocks}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_Goldilocks_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_goldilocks}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
        ))
    } else {
        Ok(String::new())
    };

    let plonky3_tests: Result<String, String> = if include_plonky3 {
        use crate::plonky3_stark::{
            encode_poseidon2_params, encode_poseidon_params, encode_rescue_params,
            Poseidon2Params, PoseidonParams, RescueParams,
            FIELD_P3_BABY_BEAR_ID, FIELD_P3_KOALA_BEAR_ID, FIELD_P3_GOLDILOCKS_ID,
            HASH_P3_POSEIDON2_ID, HASH_P3_POSEIDON_ID, HASH_P3_RESCUE_ID, HASH_P3_BLAKE3_ID,
            PLONKY3_AIR_FIBONACCI_ID, PLONKY3_AIR_TRIBONACCI_ID,
        };

        let mut out = String::new();
        let mut push_test = |label: &str,
                             seed: &[u8],
                             receipt: crate::stark_receipt::CanonicalStarkReceipt|
         -> Result<(), String> {
            let proof_hex = make_stark_calldata_hex(seed, vec![receipt])?;
            out.push_str(&format!(
                r#"
    function test_GLYPH_STARK_Plonky3_{label}_Succeeds() public {{
        bytes memory proof = hex"{proof_hex}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_Plonky3_{label}_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
            ));
            Ok(())
        };

        let poseidon2_profile = |seed: u64| build_plonky3_profile(
            encode_poseidon2_params(&Poseidon2Params { width: 16, seed }),
        );
        let poseidon_profile = |alpha: u64| build_plonky3_profile(
            encode_poseidon_params(&PoseidonParams {
                width: 16,
                alpha,
                half_full_rounds: 8,
                partial_rounds: 56,
                seed: 0,
            }),
        );
        let rescue_profile = |alpha: u64| build_plonky3_profile(
            encode_rescue_params(&RescueParams {
                width: 16,
                alpha,
                capacity: 4,
                sec_level: 128,
                seed: 0,
            }),
        );

        let baby_poseidon2 = load_or_build_plonky3_receipt_fixture(
            "scripts/tools/fixtures/plonky3_babybear_poseidon2_receipt.txt",
            poseidon2_profile(0),
            build_plonky3_program(
                FIELD_P3_BABY_BEAR_ID,
                HASH_P3_POSEIDON2_ID,
                PLONKY3_AIR_FIBONACCI_ID,
            ),
        )?;
        push_test(
            "BabyBear_Poseidon2",
            b"glyph-option-d-stark-gkr-plonky3-babybear-poseidon2",
            baby_poseidon2,
        )?;
        let baby_poseidon2_tribonacci = load_or_build_plonky3_receipt_fixture(
            "scripts/tools/fixtures/plonky3_babybear_poseidon2_tribonacci_receipt.txt",
            poseidon2_profile(0),
            build_plonky3_program(
                FIELD_P3_BABY_BEAR_ID,
                HASH_P3_POSEIDON2_ID,
                PLONKY3_AIR_TRIBONACCI_ID,
            ),
        )?;
        push_test(
            "BabyBear_Poseidon2_Tribonacci",
            b"glyph-option-d-stark-gkr-plonky3-babybear-poseidon2-tribonacci",
            baby_poseidon2_tribonacci,
        )?;

        let baby_poseidon = load_or_build_plonky3_receipt_fixture(
            "scripts/tools/fixtures/plonky3_babybear_poseidon_receipt.txt",
            poseidon_profile(7),
            build_plonky3_program(
                FIELD_P3_BABY_BEAR_ID,
                HASH_P3_POSEIDON_ID,
                PLONKY3_AIR_FIBONACCI_ID,
            ),
        )?;
        push_test(
            "BabyBear_Poseidon",
            b"glyph-option-d-stark-gkr-plonky3-babybear-poseidon",
            baby_poseidon,
        )?;

        let baby_rescue = load_or_build_plonky3_receipt_fixture(
            "scripts/tools/fixtures/plonky3_babybear_rescue_receipt.txt",
            rescue_profile(7),
            build_plonky3_program(
                FIELD_P3_BABY_BEAR_ID,
                HASH_P3_RESCUE_ID,
                PLONKY3_AIR_FIBONACCI_ID,
            ),
        )?;
        push_test(
            "BabyBear_Rescue",
            b"glyph-option-d-stark-gkr-plonky3-babybear-rescue",
            baby_rescue,
        )?;

        let baby_blake3 = load_or_build_plonky3_receipt_fixture(
            "scripts/tools/fixtures/plonky3_babybear_blake3_receipt.txt",
            build_plonky3_profile(Vec::new()),
            build_plonky3_program(
                FIELD_P3_BABY_BEAR_ID,
                HASH_P3_BLAKE3_ID,
                PLONKY3_AIR_FIBONACCI_ID,
            ),
        )?;
        push_test(
            "BabyBear_Blake3",
            b"glyph-option-d-stark-gkr-plonky3-babybear-blake3",
            baby_blake3,
        )?;

        let koala_poseidon2 = load_or_build_plonky3_receipt_fixture(
            "scripts/tools/fixtures/plonky3_koalabear_poseidon2_receipt.txt",
            poseidon2_profile(0),
            build_plonky3_program(
                FIELD_P3_KOALA_BEAR_ID,
                HASH_P3_POSEIDON2_ID,
                PLONKY3_AIR_FIBONACCI_ID,
            ),
        )?;
        push_test(
            "KoalaBear_Poseidon2",
            b"glyph-option-d-stark-gkr-plonky3-koalabear-poseidon2",
            koala_poseidon2,
        )?;
        let koala_poseidon2_tribonacci = load_or_build_plonky3_receipt_fixture(
            "scripts/tools/fixtures/plonky3_koalabear_poseidon2_tribonacci_receipt.txt",
            poseidon2_profile(0),
            build_plonky3_program(
                FIELD_P3_KOALA_BEAR_ID,
                HASH_P3_POSEIDON2_ID,
                PLONKY3_AIR_TRIBONACCI_ID,
            ),
        )?;
        push_test(
            "KoalaBear_Poseidon2_Tribonacci",
            b"glyph-option-d-stark-gkr-plonky3-koalabear-poseidon2-tribonacci",
            koala_poseidon2_tribonacci,
        )?;

        let koala_poseidon = load_or_build_plonky3_receipt_fixture(
            "scripts/tools/fixtures/plonky3_koalabear_poseidon_receipt.txt",
            poseidon_profile(3),
            build_plonky3_program(
                FIELD_P3_KOALA_BEAR_ID,
                HASH_P3_POSEIDON_ID,
                PLONKY3_AIR_FIBONACCI_ID,
            ),
        )?;
        push_test(
            "KoalaBear_Poseidon",
            b"glyph-option-d-stark-gkr-plonky3-koalabear-poseidon",
            koala_poseidon,
        )?;

        let koala_rescue = load_or_build_plonky3_receipt_fixture(
            "scripts/tools/fixtures/plonky3_koalabear_rescue_receipt.txt",
            rescue_profile(3),
            build_plonky3_program(
                FIELD_P3_KOALA_BEAR_ID,
                HASH_P3_RESCUE_ID,
                PLONKY3_AIR_FIBONACCI_ID,
            ),
        )?;
        push_test(
            "KoalaBear_Rescue",
            b"glyph-option-d-stark-gkr-plonky3-koalabear-rescue",
            koala_rescue,
        )?;

        let koala_blake3 = load_or_build_plonky3_receipt_fixture(
            "scripts/tools/fixtures/plonky3_koalabear_blake3_receipt.txt",
            build_plonky3_profile(Vec::new()),
            build_plonky3_program(
                FIELD_P3_KOALA_BEAR_ID,
                HASH_P3_BLAKE3_ID,
                PLONKY3_AIR_FIBONACCI_ID,
            ),
        )?;
        push_test(
            "KoalaBear_Blake3",
            b"glyph-option-d-stark-gkr-plonky3-koalabear-blake3",
            koala_blake3,
        )?;

        let goldilocks_poseidon2 = load_or_build_plonky3_receipt_fixture(
            "scripts/tools/fixtures/plonky3_goldilocks_poseidon2_receipt.txt",
            poseidon2_profile(0),
            build_plonky3_program(
                FIELD_P3_GOLDILOCKS_ID,
                HASH_P3_POSEIDON2_ID,
                PLONKY3_AIR_FIBONACCI_ID,
            ),
        )?;
        push_test(
            "Goldilocks_Poseidon2",
            b"glyph-option-d-stark-gkr-plonky3-goldilocks-poseidon2",
            goldilocks_poseidon2,
        )?;
        let goldilocks_poseidon2_tribonacci = load_or_build_plonky3_receipt_fixture(
            "scripts/tools/fixtures/plonky3_goldilocks_poseidon2_tribonacci_receipt.txt",
            poseidon2_profile(0),
            build_plonky3_program(
                FIELD_P3_GOLDILOCKS_ID,
                HASH_P3_POSEIDON2_ID,
                PLONKY3_AIR_TRIBONACCI_ID,
            ),
        )?;
        push_test(
            "Goldilocks_Poseidon2_Tribonacci",
            b"glyph-option-d-stark-gkr-plonky3-goldilocks-poseidon2-tribonacci",
            goldilocks_poseidon2_tribonacci,
        )?;

        let goldilocks_poseidon = load_or_build_plonky3_receipt_fixture(
            "scripts/tools/fixtures/plonky3_goldilocks_poseidon_receipt.txt",
            poseidon_profile(7),
            build_plonky3_program(
                FIELD_P3_GOLDILOCKS_ID,
                HASH_P3_POSEIDON_ID,
                PLONKY3_AIR_FIBONACCI_ID,
            ),
        )?;
        push_test(
            "Goldilocks_Poseidon",
            b"glyph-option-d-stark-gkr-plonky3-goldilocks-poseidon",
            goldilocks_poseidon,
        )?;

        let goldilocks_rescue = load_or_build_plonky3_receipt_fixture(
            "scripts/tools/fixtures/plonky3_goldilocks_rescue_receipt.txt",
            rescue_profile(7),
            build_plonky3_program(
                FIELD_P3_GOLDILOCKS_ID,
                HASH_P3_RESCUE_ID,
                PLONKY3_AIR_FIBONACCI_ID,
            ),
        )?;
        push_test(
            "Goldilocks_Rescue",
            b"glyph-option-d-stark-gkr-plonky3-goldilocks-rescue",
            goldilocks_rescue,
        )?;

        let goldilocks_blake3 = load_or_build_plonky3_receipt_fixture(
            "scripts/tools/fixtures/plonky3_goldilocks_blake3_receipt.txt",
            build_plonky3_profile(Vec::new()),
            build_plonky3_program(
                FIELD_P3_GOLDILOCKS_ID,
                HASH_P3_BLAKE3_ID,
                PLONKY3_AIR_FIBONACCI_ID,
            ),
        )?;
        push_test(
            "Goldilocks_Blake3",
            b"glyph-option-d-stark-gkr-plonky3-goldilocks-blake3",
            goldilocks_blake3,
        )?;

        Ok(out)
    } else {
        Ok(String::new())
    };

    let miden_tests: Result<String, String> = if include_miden {
        let seed_rpo = b"glyph-option-d-stark-gkr-miden-rpo";
        let receipt_rpo = load_or_build_miden_receipt_fixture(
            "scripts/tools/fixtures/miden_rpo_receipt.txt",
            miden_prover::HashFunction::Rpo256,
        )?;
        let proof_hex_rpo = make_stark_calldata_hex(seed_rpo, vec![receipt_rpo])?;

        let seed_blake3 = b"glyph-option-d-stark-gkr-miden-blake3";
        let receipt_blake3 = load_or_build_miden_receipt_fixture(
            "scripts/tools/fixtures/miden_blake3_receipt.txt",
            miden_prover::HashFunction::Blake3_256,
        )?;
        let proof_hex_blake3 = make_stark_calldata_hex(seed_blake3, vec![receipt_blake3])?;
        Ok(format!(
            r#"
    function test_GLYPH_STARK_Miden_Rpo_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_rpo}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_Miden_Rpo_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_rpo}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}

    function test_GLYPH_STARK_Miden_Blake3_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_blake3}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_Miden_Blake3_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_blake3}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
        ))
    } else {
        Ok(String::new())
    };

    let cairo_tests: Result<String, String> = if include_cairo {
        let seed = b"glyph-option-d-stark-gkr-cairo-stone6-keccak160";
        let receipt = load_or_build_cairo_receipt_fixture(
            "scripts/tools/fixtures/cairo_stone6_keccak_160_lsb_example_proof.json",
            crate::cairo_stark::LAYOUT_STARKNET_WITH_KECCAK_ID,
            crate::cairo_stark::HASH_KECCAK_160_LSB_ID,
            crate::cairo_stark::STONE6_ID,
            crate::cairo_stark::VERIFIER_MONOLITH_ID,
        )?;
        let proof_hex = make_stark_calldata_hex(seed, vec![receipt])?;
        Ok(format!(
            r#"
    function test_GLYPH_STARK_Cairo_Stone6_Keccak160_Succeeds() public {{
        bytes memory proof = hex"{proof_hex}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_Cairo_Stone6_Keccak160_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
        ))
    } else {
        Ok(String::new())
    };

    let seed_circle = b"glyph-option-d-stark-gkr-circle";
    let receipt_circle = load_fast_circle_receipt_fixture()?;
    let canonical_circle: Vec<crate::stark_receipt::CanonicalStarkReceipt> = vec![
        receipt_circle,
    ];
    let (commitment_tag_circle, point_tag_circle, claim128_circle) =
        crate::stark_adapter::verified_canonical_stark_receipts_to_glyph_artifact(
            seed_circle,
            &canonical_circle,
        )
        .map_err(|e| format!("circle receipt must verify: {e}"))?;
    let claim_circle = crate::glyph_gkr::gkr_canonicalize_u128(claim128_circle);

    let proof_circle = prove_packed_artifact_poly_sumcheck(
        &commitment_tag_circle,
        &point_tag_circle,
        &claim_circle,
        chain_id,
        contract_addr,
        rounds,
    );
    let calldata_circle = encode_artifact_poly_bound_packed_calldata_be(
        &proof_circle,
        chain_id,
        contract_addr,
        &commitment_tag_circle,
        &point_tag_circle,
        &claim_circle,
        false,
    );
    let proof_hex_circle = hex::encode(&calldata_circle);

    let seed_baby_bear = b"glyph-option-d-stark-gkr-baby-bear";
    let receipt_baby_bear = load_fast_circle_baby_bear_receipt_fixture()?;
    let canonical_baby_bear: Vec<crate::stark_receipt::CanonicalStarkReceipt> =
        vec![receipt_baby_bear];
    let (commitment_tag_baby_bear, point_tag_baby_bear, claim128_baby_bear) =
        crate::stark_adapter::verified_canonical_stark_receipts_to_glyph_artifact(
            seed_baby_bear,
            &canonical_baby_bear,
        )
        .map_err(|e| format!("baby bear receipt must verify: {e}"))?;
    let claim_baby_bear = crate::glyph_gkr::gkr_canonicalize_u128(claim128_baby_bear);

    let proof_baby_bear = prove_packed_artifact_poly_sumcheck(
        &commitment_tag_baby_bear,
        &point_tag_baby_bear,
        &claim_baby_bear,
        chain_id,
        contract_addr,
        rounds,
    );
    let calldata_baby_bear = encode_artifact_poly_bound_packed_calldata_be(
        &proof_baby_bear,
        chain_id,
        contract_addr,
        &commitment_tag_baby_bear,
        &point_tag_baby_bear,
        &claim_baby_bear,
        false,
    );
    let proof_hex_baby_bear = hex::encode(&calldata_baby_bear);
    let baby_bear_tests = format!(
        r#"
    function test_GLYPH_STARK_BabyBear_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_baby_bear}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_BabyBear_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_baby_bear}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
    );

    let seed_baby_bear_std = b"glyph-option-d-stark-gkr-baby-bear-std";
    let receipt_baby_bear_std = build_standard_baby_bear_receipt_fixture()?;
    let canonical_baby_bear_std: Vec<crate::stark_receipt::CanonicalStarkReceipt> =
        vec![receipt_baby_bear_std];
    let (commitment_tag_baby_bear_std, point_tag_baby_bear_std, claim128_baby_bear_std) =
        crate::stark_adapter::verified_canonical_stark_receipts_to_glyph_artifact(
            seed_baby_bear_std,
            &canonical_baby_bear_std,
        )
        .map_err(|e| format!("standard baby bear receipt must verify: {e}"))?;
    let claim_baby_bear_std =
        crate::glyph_gkr::gkr_canonicalize_u128(claim128_baby_bear_std);

    let proof_baby_bear_std = prove_packed_artifact_poly_sumcheck(
        &commitment_tag_baby_bear_std,
        &point_tag_baby_bear_std,
        &claim_baby_bear_std,
        chain_id,
        contract_addr,
        rounds,
    );
    let calldata_baby_bear_std = encode_artifact_poly_bound_packed_calldata_be(
        &proof_baby_bear_std,
        chain_id,
        contract_addr,
        &commitment_tag_baby_bear_std,
        &point_tag_baby_bear_std,
        &claim_baby_bear_std,
        false,
    );
    let proof_hex_baby_bear_std = hex::encode(&calldata_baby_bear_std);
    let baby_bear_std_tests = format!(
        r#"
    function test_GLYPH_STARK_BabyBearStandard_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_baby_bear_std}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_BabyBearStandard_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_baby_bear_std}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
    );

    let seed_baby_bear_std_blake3 = b"glyph-option-d-stark-gkr-baby-bear-std-blake3";
    let receipt_baby_bear_std_blake3 =
        build_standard_baby_bear_receipt_fixture_with_hash(crate::standard_stark::HASH_BLAKE3_ID)?;
    let proof_hex_baby_bear_std_blake3 = make_stark_calldata_hex(
        seed_baby_bear_std_blake3,
        vec![receipt_baby_bear_std_blake3],
    )?;
    let baby_bear_std_blake3_tests = format!(
        r#"
    function test_GLYPH_STARK_BabyBearStandard_Blake3_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_baby_bear_std_blake3}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_BabyBearStandard_Blake3_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_baby_bear_std_blake3}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
    );

    let seed_baby_bear_std_poseidon = b"glyph-option-d-stark-gkr-baby-bear-std-poseidon";
    let receipt_baby_bear_std_poseidon =
        build_standard_baby_bear_receipt_fixture_with_hash(crate::standard_stark::HASH_POSEIDON_ID)?;
    let proof_hex_baby_bear_std_poseidon = make_stark_calldata_hex(
        seed_baby_bear_std_poseidon,
        vec![receipt_baby_bear_std_poseidon],
    )?;
    let baby_bear_std_poseidon_tests = format!(
        r#"
    function test_GLYPH_STARK_BabyBearStandard_Poseidon_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_baby_bear_std_poseidon}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_BabyBearStandard_Poseidon_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_baby_bear_std_poseidon}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
    );

    let seed_baby_bear_std_rescue = b"glyph-option-d-stark-gkr-baby-bear-std-rescue";
    let receipt_baby_bear_std_rescue =
        build_standard_baby_bear_receipt_fixture_with_hash(crate::standard_stark::HASH_RESCUE_ID)?;
    let proof_hex_baby_bear_std_rescue = make_stark_calldata_hex(
        seed_baby_bear_std_rescue,
        vec![receipt_baby_bear_std_rescue],
    )?;
    let baby_bear_std_rescue_tests = format!(
        r#"
    function test_GLYPH_STARK_BabyBearStandard_Rescue_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_baby_bear_std_rescue}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_BabyBearStandard_Rescue_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_baby_bear_std_rescue}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
    );

    let circle_air_m31 = b"circle_do_work_expr:x^3+42,linear:m31";
    let circle_air_baby_bear = b"circle_do_work_expr:x^3+42,linear:baby-bear";
    let circle_air_koala_bear = b"circle_do_work_expr:x^3+42,linear:koala-bear";

    let seed_circle_poseidon_m31 = b"glyph-option-d-stark-gkr-circle-poseidon-m31";
    let receipt_circle_poseidon_m31 = build_circle_receipt_fixture_with_hash(
        crate::circle_stark::FIELD_M31_CIRCLE_ID,
        crate::circle_stark::HASH_POSEIDON_ID,
        circle_air_m31,
    )?;
    let proof_hex_circle_poseidon_m31 =
        make_stark_calldata_hex(seed_circle_poseidon_m31, vec![receipt_circle_poseidon_m31])?;
    let circle_poseidon_m31_tests = format!(
        r#"
    function test_GLYPH_STARK_Circle_Poseidon_M31_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_circle_poseidon_m31}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_Circle_Poseidon_M31_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_circle_poseidon_m31}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
    );

    let seed_circle_rescue_m31 = b"glyph-option-d-stark-gkr-circle-rescue-m31";
    let receipt_circle_rescue_m31 = build_circle_receipt_fixture_with_hash(
        crate::circle_stark::FIELD_M31_CIRCLE_ID,
        crate::circle_stark::HASH_RESCUE_ID,
        circle_air_m31,
    )?;
    let proof_hex_circle_rescue_m31 =
        make_stark_calldata_hex(seed_circle_rescue_m31, vec![receipt_circle_rescue_m31])?;
    let circle_rescue_m31_tests = format!(
        r#"
    function test_GLYPH_STARK_Circle_Rescue_M31_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_circle_rescue_m31}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_Circle_Rescue_M31_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_circle_rescue_m31}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
    );

    let seed_circle_poseidon_baby = b"glyph-option-d-stark-gkr-circle-poseidon-babybear";
    let receipt_circle_poseidon_baby = build_circle_receipt_fixture_with_hash(
        crate::circle_stark::FIELD_BABY_BEAR_CIRCLE_ID,
        crate::circle_stark::HASH_POSEIDON_ID,
        circle_air_baby_bear,
    )?;
    let proof_hex_circle_poseidon_baby =
        make_stark_calldata_hex(seed_circle_poseidon_baby, vec![receipt_circle_poseidon_baby])?;
    let circle_poseidon_baby_tests = format!(
        r#"
    function test_GLYPH_STARK_Circle_Poseidon_BabyBear_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_circle_poseidon_baby}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_Circle_Poseidon_BabyBear_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_circle_poseidon_baby}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
    );

    let seed_circle_rescue_baby = b"glyph-option-d-stark-gkr-circle-rescue-babybear";
    let receipt_circle_rescue_baby = build_circle_receipt_fixture_with_hash(
        crate::circle_stark::FIELD_BABY_BEAR_CIRCLE_ID,
        crate::circle_stark::HASH_RESCUE_ID,
        circle_air_baby_bear,
    )?;
    let proof_hex_circle_rescue_baby =
        make_stark_calldata_hex(seed_circle_rescue_baby, vec![receipt_circle_rescue_baby])?;
    let circle_rescue_baby_tests = format!(
        r#"
    function test_GLYPH_STARK_Circle_Rescue_BabyBear_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_circle_rescue_baby}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_Circle_Rescue_BabyBear_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_circle_rescue_baby}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
    );

    let seed_circle_poseidon_koala = b"glyph-option-d-stark-gkr-circle-poseidon-koalabear";
    let receipt_circle_poseidon_koala = build_circle_receipt_fixture_with_hash(
        crate::circle_stark::FIELD_KOALA_BEAR_CIRCLE_ID,
        crate::circle_stark::HASH_POSEIDON_ID,
        circle_air_koala_bear,
    )?;
    let proof_hex_circle_poseidon_koala =
        make_stark_calldata_hex(seed_circle_poseidon_koala, vec![receipt_circle_poseidon_koala])?;
    let circle_poseidon_koala_tests = format!(
        r#"
    function test_GLYPH_STARK_Circle_Poseidon_KoalaBear_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_circle_poseidon_koala}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_Circle_Poseidon_KoalaBear_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_circle_poseidon_koala}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
    );

    let seed_circle_rescue_koala = b"glyph-option-d-stark-gkr-circle-rescue-koalabear";
    let receipt_circle_rescue_koala = build_circle_receipt_fixture_with_hash(
        crate::circle_stark::FIELD_KOALA_BEAR_CIRCLE_ID,
        crate::circle_stark::HASH_RESCUE_ID,
        circle_air_koala_bear,
    )?;
    let proof_hex_circle_rescue_koala =
        make_stark_calldata_hex(seed_circle_rescue_koala, vec![receipt_circle_rescue_koala])?;
    let circle_rescue_koala_tests = format!(
        r#"
    function test_GLYPH_STARK_Circle_Rescue_KoalaBear_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_circle_rescue_koala}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_Circle_Rescue_KoalaBear_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_circle_rescue_koala}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
    );

    let seed_koala_bear = b"glyph-option-d-stark-gkr-koala-bear";
    let receipt_koala_bear = load_fast_circle_koala_bear_receipt_fixture()?;
    let canonical_koala_bear: Vec<crate::stark_receipt::CanonicalStarkReceipt> =
        vec![receipt_koala_bear];
    let (commitment_tag_koala_bear, point_tag_koala_bear, claim128_koala_bear) =
        crate::stark_adapter::verified_canonical_stark_receipts_to_glyph_artifact(
            seed_koala_bear,
            &canonical_koala_bear,
        )
        .map_err(|e| format!("koala bear receipt must verify: {e}"))?;
    let claim_koala_bear = crate::glyph_gkr::gkr_canonicalize_u128(claim128_koala_bear);

    let proof_koala_bear = prove_packed_artifact_poly_sumcheck(
        &commitment_tag_koala_bear,
        &point_tag_koala_bear,
        &claim_koala_bear,
        chain_id,
        contract_addr,
        rounds,
    );
    let calldata_koala_bear = encode_artifact_poly_bound_packed_calldata_be(
        &proof_koala_bear,
        chain_id,
        contract_addr,
        &commitment_tag_koala_bear,
        &point_tag_koala_bear,
        &claim_koala_bear,
        false,
    );
    let proof_hex_koala_bear = hex::encode(&calldata_koala_bear);
    let koala_bear_tests = format!(
        r#"
    function test_GLYPH_STARK_KoalaBear_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_koala_bear}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_KoalaBear_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_koala_bear}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
    );

    let circle_large_tests: Result<String, String> = if include_circle_large {
        let seed_circle_large = b"glyph-option-d-stark-gkr-circle-large";
        let receipt_circle_large = load_fast_circle_receipt_fixture_large()?;
        let canonical_circle_large: Vec<crate::stark_receipt::CanonicalStarkReceipt> =
            vec![receipt_circle_large];
        let (commitment_tag_circle_large, point_tag_circle_large, claim128_circle_large) =
            crate::stark_adapter::verified_canonical_stark_receipts_to_glyph_artifact(
                seed_circle_large,
                &canonical_circle_large,
            )
            .map_err(|e| format!("circle large receipt must verify: {e}"))?;
        let claim_circle_large =
            crate::glyph_gkr::gkr_canonicalize_u128(claim128_circle_large);

        let proof_circle_large = prove_packed_artifact_poly_sumcheck(
            &commitment_tag_circle_large,
            &point_tag_circle_large,
            &claim_circle_large,
            chain_id,
            contract_addr,
            rounds,
        );
        let calldata_circle_large = encode_artifact_poly_bound_packed_calldata_be(
            &proof_circle_large,
            chain_id,
            contract_addr,
            &commitment_tag_circle_large,
            &point_tag_circle_large,
            &claim_circle_large,
            false,
        );
        let proof_hex_circle_large = hex::encode(&calldata_circle_large);
        Ok(format!(
            r#"
    function test_GLYPH_STARK_CircleLarge_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_circle_large}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_CircleLarge_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_circle_large}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
        ))
    } else {
        Ok(String::new())
    };

    Ok(format!(
        r#"// SPDX-License-Identifier: MIT
// AUTO-GENERATED by GLYPH Rust Prover - DO NOT EDIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "./GLYPHVerifier.sol";

contract GLYPH_STARK_Test is Test {{
    address internal constant TARGET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function setUp() public {{
        vm.chainId({chain_id});
        GLYPHVerifier impl = new GLYPHVerifier();
        vm.etch(TARGET, address(impl).code);
    }}

    function test_GLYPH_STARK_F128_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_f128}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_F128_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_f128}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}

{f64_tests}

{goldilocks_tests}

{plonky3_tests}

{miden_tests}

{cairo_tests}

    function test_GLYPH_STARK_Circle_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_circle}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_STARK_Circle_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_circle}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}

{circle_poseidon_m31_tests}

{circle_rescue_m31_tests}

{baby_bear_tests}

{circle_poseidon_baby_tests}

{circle_rescue_baby_tests}

{baby_bear_std_tests}

{baby_bear_std_blake3_tests}

{baby_bear_std_poseidon_tests}

{baby_bear_std_rescue_tests}

{koala_bear_tests}

{circle_poseidon_koala_tests}

{circle_rescue_koala_tests}

{circle_large_tests}
}}
"#,
        chain_id = chain_id,
        proof_hex_f128 = proof_hex_f128,
        f64_tests = f64_tests?,
        goldilocks_tests = goldilocks_tests?,
        plonky3_tests = plonky3_tests?,
        miden_tests = miden_tests?,
        cairo_tests = cairo_tests?,
        proof_hex_circle = proof_hex_circle,
        circle_poseidon_m31_tests = circle_poseidon_m31_tests,
        circle_rescue_m31_tests = circle_rescue_m31_tests,
        baby_bear_tests = baby_bear_tests,
        circle_poseidon_baby_tests = circle_poseidon_baby_tests,
        circle_rescue_baby_tests = circle_rescue_baby_tests,
        baby_bear_std_tests = baby_bear_std_tests,
        baby_bear_std_blake3_tests = baby_bear_std_blake3_tests,
        baby_bear_std_poseidon_tests = baby_bear_std_poseidon_tests,
        baby_bear_std_rescue_tests = baby_bear_std_rescue_tests,
        koala_bear_tests = koala_bear_tests,
        circle_poseidon_koala_tests = circle_poseidon_koala_tests,
        circle_rescue_koala_tests = circle_rescue_koala_tests,
        circle_large_tests = circle_large_tests?
    ))
}

pub fn generate_glyph_hash_merge_solidity_test_file() -> Result<String, String> {
    use crate::glyph_gkr::encode_artifact_poly_bound_packed_calldata_be;
    use crate::glyph_gkr::prove_packed_artifact_poly_sumcheck;

    let chain_id = 31337u64;
    let contract_addr = [0xeeu8; 20];
    let seed = b"glyph-hash-merge";

    let mut seed_input = Vec::with_capacity(seed.len() + 1);
    seed_input.extend_from_slice(seed);
    seed_input.push(0);
    let left = crate::adapters::keccak256(&seed_input);
    let last = seed_input.len() - 1;
    seed_input[last] = 1;
    let right = crate::adapters::keccak256(&seed_input);
    let mut digest_input = [0u8; 64];
    digest_input[..32].copy_from_slice(&left);
    digest_input[32..].copy_from_slice(&right);
    let digest = crate::adapters::keccak256(&digest_input);

    let ir = crate::adapter_ir::AdapterIr {
        version: 1,
        ops: vec![crate::adapter_ir::AdapterIrOp {
            kernel_id: crate::adapter_ir::kernel_id::HASH_SHA3_MERGE,
            args: Vec::new(),
        }],
    };
    let (commitment_tag, point_tag, claim128) =
        crate::adapter_ir::derive_glyph_artifact_from_hash_ir(
            &ir.encode(),
            &left,
            &right,
        )
        .map_err(|e| format!("hash merge artifact failed: {e}"))?;

    let claim = crate::glyph_gkr::gkr_canonicalize_u128(claim128);

    let rounds = 5usize;
    let proof = prove_packed_artifact_poly_sumcheck(
        &commitment_tag,
        &point_tag,
        &claim,
        chain_id,
        contract_addr,
        rounds,
    );
    let calldata = encode_artifact_poly_bound_packed_calldata_be(
        &proof,
        chain_id,
        contract_addr,
        &commitment_tag,
        &point_tag,
        &claim,
        true,
    );

    let proof_hex = hex::encode(&calldata);
    let left_hex = hex::encode(left);
    let right_hex = hex::encode(right);
    let digest_hex = hex::encode(digest);

    Ok(format!(
        r#"// SPDX-License-Identifier: MIT
// AUTO-GENERATED by GLYPH Rust Prover - DO NOT EDIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "./GLYPHVerifier.sol";

contract GLYPH_HASH_Test is Test {{
    address internal constant TARGET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function setUp() public {{
        vm.chainId({chain_id});
        GLYPHVerifier impl = new GLYPHVerifier();
        vm.etch(TARGET, address(impl).code);
    }}

    function test_GLYPH_HASH_Succeeds() public {{
        bytes memory proof = hex"{proof_hex}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_HASH_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}

    function test_GLYPH_HASH_Digest_Matches() public pure {{
        bytes32 lhs = 0x{left_hex};
        bytes32 rhs = 0x{right_hex};
        bytes32 expected = 0x{digest_hex};
        bytes32 computed = keccak256(abi.encodePacked(lhs, rhs));
        assertEq(computed, expected, "keccak merge digest");
    }}
}}
"#,
        chain_id = chain_id,
        proof_hex = proof_hex,
        left_hex = left_hex,
        right_hex = right_hex,
        digest_hex = digest_hex
    ))
}

fn fake_ivc_opening(
    seed: &[u8],
) -> Result<crate::ivc_adapter::BaseFoldPcsOpeningProof, String> {
    use crate::pcs_basefold::{BaseFoldConfig, BaseFoldProver};
    use binius_field::underlier::WithUnderlier;
    let inst = crate::adapters::keccak256(seed);
    let instance_digests = vec![inst];
    let weights = crate::glyph_basefold::derive_basefold_weights(&instance_digests)
        .map_err(|e| format!("basefold weights failed: {e}"))?;
    let n_vars = 3usize;
    let eval_point = crate::glyph_basefold::derive_binius_eval_point(seed, 0, n_vars);
    let evals: Vec<binius_field::BinaryField128b> = (0..(1usize << n_vars))
        .map(|i| binius_field::BinaryField128b::from_underlier((i as u128) + 1))
        .collect();
    let prover = BaseFoldProver::commit(&evals, n_vars, BaseFoldConfig::default())
        .map_err(|e| format!("basefold commit failed: {e}"))?;
    let commitment = prover.commitment();
    let opening = prover
        .open(&eval_point)
        .map_err(|e| format!("basefold open failed: {e}"))?;

    Ok(crate::ivc_adapter::BaseFoldPcsOpeningProof {
        instance_digests,
        weights,
        commitment,
        eval_point,
        claimed_eval: opening.eval,
        proofs: opening.proofs,
    })
}

fn fake_ivc_r1cs_receipt() -> crate::ivc_r1cs::R1csReceipt {
    use crate::ivc_r1cs::{R1csConstraint, R1csLinearCombination, R1csReceipt, R1csTerm};
    use ark_bn254::Fr;

    let one = Fr::ONE;
    let two = one + one;
    let three = two + one;
    let six = three + three;
    let constraint = R1csConstraint {
        a: R1csLinearCombination {
            terms: vec![R1csTerm { var_idx: 1, coeff: one }],
        },
        b: R1csLinearCombination {
            terms: vec![R1csTerm { var_idx: 2, coeff: one }],
        },
        c: R1csLinearCombination {
            terms: vec![R1csTerm { var_idx: 3, coeff: one }],
        },
    };
    R1csReceipt {
        num_vars: 4,
        num_constraints: 1,
        constraints: vec![constraint],
        witness: vec![one, two, three, six],
        u: one,
        error: vec![Fr::ZERO],
    }
}

fn fake_ivc_r1cs_receipt_bytes() -> Vec<u8> {
    crate::ivc_r1cs::encode_r1cs_receipt(&fake_ivc_r1cs_receipt())
}

fn ivc_receipt_hash(receipt_bytes: &[u8]) -> [u8; 32] {
    crate::adapters::keccak256(receipt_bytes)
}

fn ivc_receipt_tag(domain: &[u8], receipt_hash: &[u8; 32]) -> [u8; 32] {
    crate::adapters::keccak256_concat(&[domain, receipt_hash])
}

fn ivc_receipt_tag_indexed(domain: &[u8], receipt_hash: &[u8; 32], idx: u32) -> [u8; 32] {
    let idx_bytes = idx.to_be_bytes();
    crate::adapters::keccak256_concat(&[domain, receipt_hash, &idx_bytes])
}

fn fake_ivc_nova_proof() -> Result<crate::ivc_adapter::NovaFoldingProof, String> {
    let receipt = fake_ivc_r1cs_receipt();
    let receipt_bytes = crate::ivc_r1cs::encode_r1cs_receipt(&receipt);
    let receipt_hash = ivc_receipt_hash(&receipt_bytes);
    let snark_proof = match load_ivc_nova_external_proof_fixture()? {
        Some(proof) => proof,
        None => generate_and_store_ivc_nova_external_proof_fixture(&receipt)?,
    };
    Ok(crate::ivc_adapter::NovaFoldingProof {
        u: ivc_receipt_tag(crate::ivc_adapter::GLYPH_IVC_NOVA_U_TAG_DOMAIN, &receipt_hash),
        e_commitment: ivc_receipt_tag(crate::ivc_adapter::GLYPH_IVC_NOVA_E_TAG_DOMAIN, &receipt_hash),
        w_commitment: ivc_receipt_tag(crate::ivc_adapter::GLYPH_IVC_NOVA_W_TAG_DOMAIN, &receipt_hash),
        public_inputs: Vec::new(),
        t_commitment: ivc_receipt_tag(crate::ivc_adapter::GLYPH_IVC_NOVA_T_TAG_DOMAIN, &receipt_hash),
        acc_u: ivc_receipt_tag(crate::ivc_adapter::GLYPH_IVC_NOVA_ACC_U_TAG_DOMAIN, &receipt_hash),
        acc_e_commitment: ivc_receipt_tag(crate::ivc_adapter::GLYPH_IVC_NOVA_ACC_E_TAG_DOMAIN, &receipt_hash),
        acc_w_commitment: ivc_receipt_tag(crate::ivc_adapter::GLYPH_IVC_NOVA_ACC_W_TAG_DOMAIN, &receipt_hash),
        snark_proof: Some(Bytes::from(snark_proof)),
        r1cs_receipt: Bytes::from(receipt_bytes),
    })
}

fn load_ivc_nova_external_proof_fixture() -> Result<Option<Vec<u8>>, String> {
    if std::env::var("UPDATE_SNAPSHOTS").ok().as_deref() == Some("1") {
        return Ok(None);
    }
    let path = "scripts/tools/fixtures/ivc_nova_external_proof.txt";
    let raw = std::fs::read_to_string(path).ok();
    let raw = match raw {
        Some(raw) => raw,
        None => return Ok(None),
    };
    for line in raw.lines() {
        if let Some(rest) = line.strip_prefix("proof_hex=") {
            return hex::decode(rest.trim())
                .map(Some)
                .map_err(|e| format!("ivc nova proof hex decode failed: {e}"));
        }
    }
    Ok(None)
}

fn generate_and_store_ivc_nova_external_proof_fixture(
    receipt: &crate::ivc_r1cs::R1csReceipt,
) -> Result<Vec<u8>, String> {
    let proof = crate::ivc_nova::generate_nova_external_proof_bytes(receipt)
        .map_err(|e| format!("nova external proof failed: {e}"))?;
    let path = "scripts/tools/fixtures/ivc_nova_external_proof.txt";
    if let Some(parent) = std::path::Path::new(path).parent() {
        std::fs::create_dir_all(parent)
            .map_err(|e| format!("create fixture dir failed: {e}"))?;
    }
    let content = format!("proof_hex={}\n", hex::encode(&proof));
    std::fs::write(path, content)
        .map_err(|e| format!("write nova external proof fixture failed: {e}"))?;
    Ok(proof)
}

#[cfg(feature = "ivc-supernova")]
fn fake_ivc_supernova_proof() -> Result<crate::ivc_adapter::SuperNovaProof, String> {
    let receipt_bytes = fake_ivc_r1cs_receipt_bytes();
    let receipt_hash = ivc_receipt_hash(&receipt_bytes);
    let receipt = crate::ivc_r1cs::decode_r1cs_receipt(&receipt_bytes)
        .map_err(|e| format!("r1cs receipt decode failed: {e}"))?;
    let snark_proof = match load_ivc_supernova_external_proof_fixture()? {
        Some(proof) => proof,
        None => generate_and_store_ivc_supernova_external_proof_fixture(&receipt)?,
    };
    Ok(crate::ivc_adapter::SuperNovaProof {
        num_circuits: 1,
        selector_index: 0,
        running_instance_commitments: vec![
            ivc_receipt_tag_indexed(
                crate::ivc_adapter::GLYPH_IVC_SUPERNOVA_RIC_TAG_DOMAIN,
                &receipt_hash,
                0,
            ),
        ],
        step_u: ivc_receipt_tag(
            crate::ivc_adapter::GLYPH_IVC_SUPERNOVA_STEP_U_TAG_DOMAIN,
            &receipt_hash,
        ),
        step_e_commitment: ivc_receipt_tag(
            crate::ivc_adapter::GLYPH_IVC_SUPERNOVA_STEP_E_TAG_DOMAIN,
            &receipt_hash,
        ),
        step_w_commitment: ivc_receipt_tag(
            crate::ivc_adapter::GLYPH_IVC_SUPERNOVA_STEP_W_TAG_DOMAIN,
            &receipt_hash,
        ),
        step_t_commitment: ivc_receipt_tag(
            crate::ivc_adapter::GLYPH_IVC_SUPERNOVA_STEP_T_TAG_DOMAIN,
            &receipt_hash,
        ),
        public_inputs: Vec::new(),
        snark_proof: Some(Bytes::from(snark_proof)),
        r1cs_receipt: Bytes::from(receipt_bytes),
    })
}

#[cfg(feature = "ivc-supernova")]
fn load_ivc_supernova_external_proof_fixture() -> Result<Option<Vec<u8>>, String> {
    if std::env::var("UPDATE_SNAPSHOTS").ok().as_deref() == Some("1") {
        return Ok(None);
    }
    let path = "scripts/tools/fixtures/ivc_supernova_external_proof.txt";
    let raw = std::fs::read_to_string(path).ok();
    let raw = match raw {
        Some(raw) => raw,
        None => return Ok(None),
    };
    for line in raw.lines() {
        if let Some(rest) = line.strip_prefix("proof_hex=") {
            return hex::decode(rest.trim())
                .map(Some)
                .map_err(|e| format!("ivc supernova proof hex decode failed: {e}"));
        }
    }
    Ok(None)
}

#[cfg(feature = "ivc-supernova")]
fn generate_and_store_ivc_supernova_external_proof_fixture(
    receipt: &crate::ivc_r1cs::R1csReceipt,
) -> Result<Vec<u8>, String> {
    let proof = crate::ivc_supernova::generate_supernova_external_proof_bytes(receipt)
        .map_err(|e| format!("supernova external proof failed: {e}"))?;
    let path = "scripts/tools/fixtures/ivc_supernova_external_proof.txt";
    if let Some(parent) = std::path::Path::new(path).parent() {
        std::fs::create_dir_all(parent)
            .map_err(|e| format!("create fixture dir failed: {e}"))?;
    }
    let content = format!("proof_hex={}\n", hex::encode(&proof));
    std::fs::write(path, content)
        .map_err(|e| format!("write supernova external proof fixture failed: {e}"))?;
    Ok(proof)
}

fn load_ivc_hypernova_external_proof_fixture() -> Result<Option<Vec<u8>>, String> {
    if std::env::var("UPDATE_SNAPSHOTS").ok().as_deref() == Some("1") {
        return Ok(None);
    }
    let path = "scripts/tools/fixtures/ivc_hypernova_external_proof.txt";
    let raw = std::fs::read_to_string(path).ok();
    let raw = match raw {
        Some(raw) => raw,
        None => return Ok(None),
    };
    for line in raw.lines() {
        if let Some(rest) = line.strip_prefix("proof_hex=") {
            return hex::decode(rest.trim())
                .map(Some)
                .map_err(|e| format!("ivc hypernova proof hex decode failed: {e}"));
        }
    }
    Ok(None)
}

fn generate_and_store_ivc_hypernova_external_proof_fixture(
    receipt: &crate::ivc_r1cs::R1csReceipt,
) -> Result<Vec<u8>, String> {
    let proof = crate::ivc_hypernova::generate_hypernova_external_proof_bytes(receipt)
        .map_err(|e| format!("hypernova external proof failed: {e}"))?;
    let path = "scripts/tools/fixtures/ivc_hypernova_external_proof.txt";
    if let Some(parent) = std::path::Path::new(path).parent() {
        std::fs::create_dir_all(parent)
            .map_err(|e| format!("create fixture dir failed: {e}"))?;
    }
    let content = format!("proof_hex={}\n", hex::encode(&proof));
    std::fs::write(path, content)
        .map_err(|e| format!("write hypernova external proof fixture failed: {e}"))?;
    Ok(proof)
}

fn load_ivc_sangria_external_proof_fixture() -> Result<Option<Vec<u8>>, String> {
    if std::env::var("UPDATE_SNAPSHOTS").ok().as_deref() == Some("1") {
        return Ok(None);
    }
    let path = "scripts/tools/fixtures/ivc_sangria_external_proof.txt";
    let raw = std::fs::read_to_string(path).ok();
    let raw = match raw {
        Some(raw) => raw,
        None => return Ok(None),
    };
    for line in raw.lines() {
        if let Some(rest) = line.strip_prefix("proof_hex=") {
            return hex::decode(rest.trim())
                .map(Some)
                .map_err(|e| format!("ivc sangria proof hex decode failed: {e}"));
        }
    }
    Ok(None)
}

fn generate_and_store_ivc_sangria_external_proof_fixture(
    receipt: &crate::ivc_r1cs::R1csReceipt,
) -> Result<Vec<u8>, String> {
    let proof = crate::ivc_sangria::generate_sangria_external_proof_bytes(receipt)
        .map_err(|e| format!("sangria external proof failed: {e}"))?;
    let path = "scripts/tools/fixtures/ivc_sangria_external_proof.txt";
    if let Some(parent) = std::path::Path::new(path).parent() {
        std::fs::create_dir_all(parent)
            .map_err(|e| format!("create fixture dir failed: {e}"))?;
    }
    let content = format!("proof_hex={}\n", hex::encode(&proof));
    std::fs::write(path, content)
        .map_err(|e| format!("write sangria external proof fixture failed: {e}"))?;
    Ok(proof)
}

fn fake_ivc_hypernova_proof() -> Result<crate::ivc_adapter::HyperNovaProof, String> {
    let receipt = fake_ivc_r1cs_receipt();
    let receipt_bytes = crate::ivc_r1cs::encode_r1cs_receipt(&receipt);
    let receipt_hash = ivc_receipt_hash(&receipt_bytes);
    let snark_proof = match load_ivc_hypernova_external_proof_fixture()? {
        Some(proof) => proof,
        None => generate_and_store_ivc_hypernova_external_proof_fixture(&receipt)?,
    };
    Ok(crate::ivc_adapter::HyperNovaProof {
        num_vars: receipt.num_vars,
        num_constraints: receipt.num_constraints,
        degree: 2,
        ccs_commitment: ivc_receipt_tag(
            crate::ivc_adapter::GLYPH_IVC_HYPERNOVA_CCS_TAG_DOMAIN,
            &receipt_hash,
        ),
        sumcheck_proof: Bytes::new(),
        final_claim: ivc_receipt_tag(
            crate::ivc_adapter::GLYPH_IVC_HYPERNOVA_CLAIM_TAG_DOMAIN,
            &receipt_hash,
        ),
        pcs_opening: Bytes::new(),
        public_inputs: Vec::new(),
        snark_proof: Some(Bytes::from(snark_proof)),
        r1cs_receipt: Bytes::from(receipt_bytes),
    })
}

fn fake_ivc_sangria_proof() -> Result<crate::ivc_adapter::SangriaProof, String> {
    let receipt_bytes = fake_ivc_r1cs_receipt_bytes();
    let receipt_hash = ivc_receipt_hash(&receipt_bytes);
    let receipt = crate::ivc_r1cs::decode_r1cs_receipt(&receipt_bytes)
        .map_err(|e| format!("r1cs receipt decode failed: {e}"))?;
    let snark_proof = match load_ivc_sangria_external_proof_fixture()? {
        Some(proof) => proof,
        None => generate_and_store_ivc_sangria_external_proof_fixture(&receipt)?,
    };
    Ok(crate::ivc_adapter::SangriaProof {
        num_wires: 1,
        wire_commitments: vec![
            ivc_receipt_tag_indexed(
                crate::ivc_adapter::GLYPH_IVC_SANGRIA_WIRE_TAG_DOMAIN,
                &receipt_hash,
                0,
            ),
        ],
        acc_commitment: ivc_receipt_tag(
            crate::ivc_adapter::GLYPH_IVC_SANGRIA_ACC_TAG_DOMAIN,
            &receipt_hash,
        ),
        t_commitment: ivc_receipt_tag(
            crate::ivc_adapter::GLYPH_IVC_SANGRIA_T_TAG_DOMAIN,
            &receipt_hash,
        ),
        folding_challenge: ivc_receipt_tag(
            crate::ivc_adapter::GLYPH_IVC_SANGRIA_CHALLENGE_TAG_DOMAIN,
            &receipt_hash,
        ),
        opening_proof: Bytes::new(),
        public_inputs: Vec::new(),
        snark_proof: Some(Bytes::from(snark_proof)),
        r1cs_receipt: Bytes::from(receipt_bytes),
    })
}

fn ivc_nova_tags(proof: &crate::ivc_adapter::NovaFoldingProof) -> ([u8; 32], [u8; 32], u128) {
    let receipt_hash = ivc_receipt_hash(proof.r1cs_receipt.as_ref());
    let commitment_tag = crate::adapters::keccak256_concat(&[
        crate::ivc_adapter::GLYPH_IVC_NOVA_COMMIT_TAG_DOMAIN,
        &receipt_hash,
        &proof.acc_w_commitment,
        &proof.acc_e_commitment,
    ]);
    let point_tag = crate::adapters::keccak256_concat(&[
        crate::ivc_adapter::GLYPH_IVC_NOVA_POINT_TAG_DOMAIN,
        &receipt_hash,
        &proof.t_commitment,
    ]);
    let claim_hash = crate::adapters::keccak256_concat(&[
        crate::ivc_adapter::GLYPH_IVC_NOVA_CLAIM_TAG_DOMAIN,
        &receipt_hash,
        &proof.acc_u,
        &proof.u,
    ]);
    let mut claim_bytes = [0u8; 16];
    claim_bytes.copy_from_slice(&claim_hash[..16]);
    let claim128 = u128::from_be_bytes(claim_bytes);
    (commitment_tag, point_tag, claim128)
}

#[cfg(feature = "ivc-supernova")]
fn ivc_supernova_tags(proof: &crate::ivc_adapter::SuperNovaProof) -> ([u8; 32], [u8; 32], u128) {
    let receipt_hash = ivc_receipt_hash(proof.r1cs_receipt.as_ref());
    let mut commit_parts: Vec<&[u8]> = Vec::with_capacity(2 + proof.running_instance_commitments.len());
    commit_parts.push(crate::ivc_adapter::GLYPH_IVC_SUPERNOVA_COMMIT_TAG_DOMAIN);
    commit_parts.push(&receipt_hash);
    for ric in &proof.running_instance_commitments {
        commit_parts.push(ric);
    }
    let commitment_tag = crate::adapters::keccak256_concat(&commit_parts);
    let num_circuits_bytes = proof.num_circuits.to_be_bytes();
    let selector_bytes = proof.selector_index.to_be_bytes();
    let point_tag = crate::adapters::keccak256_concat(&[
        crate::ivc_adapter::GLYPH_IVC_SUPERNOVA_POINT_TAG_DOMAIN,
        &receipt_hash,
        &num_circuits_bytes,
        &selector_bytes,
        &proof.step_t_commitment,
    ]);
    let zero = [0u8; 32];
    let selected = proof
        .running_instance_commitments
        .get(proof.selector_index as usize)
        .map(|v| v.as_slice())
        .unwrap_or_else(|| {
            debug_assert!(false, "supernova selector index out of bounds");
            &zero
        });
    let claim_hash = crate::adapters::keccak256_concat(&[
        crate::ivc_adapter::GLYPH_IVC_SUPERNOVA_CLAIM_TAG_DOMAIN,
        &receipt_hash,
        &proof.step_u,
        selected,
    ]);
    let mut claim_bytes = [0u8; 16];
    claim_bytes.copy_from_slice(&claim_hash[..16]);
    let claim128 = u128::from_be_bytes(claim_bytes);
    (commitment_tag, point_tag, claim128)
}

fn ivc_hypernova_tags(proof: &crate::ivc_adapter::HyperNovaProof) -> ([u8; 32], [u8; 32], u128) {
    let receipt_hash = ivc_receipt_hash(proof.r1cs_receipt.as_ref());
    let num_vars_bytes = proof.num_vars.to_be_bytes();
    let num_constraints_bytes = proof.num_constraints.to_be_bytes();
    let commitment_tag = crate::adapters::keccak256_concat(&[
        crate::ivc_adapter::GLYPH_IVC_HYPERNOVA_COMMIT_TAG_DOMAIN,
        &receipt_hash,
        &proof.ccs_commitment,
        &num_vars_bytes,
        &num_constraints_bytes,
    ]);
    let point_tag = crate::adapters::keccak256_concat(&[
        crate::ivc_adapter::GLYPH_IVC_HYPERNOVA_POINT_TAG_DOMAIN,
        &receipt_hash,
        &proof.final_claim,
    ]);
    let claim_hash = crate::adapters::keccak256_concat(&[
        crate::ivc_adapter::GLYPH_IVC_HYPERNOVA_CLAIM_TAG_DOMAIN,
        &receipt_hash,
        &proof.final_claim,
    ]);
    let mut claim_bytes = [0u8; 16];
    claim_bytes.copy_from_slice(&claim_hash[..16]);
    let claim128 = u128::from_be_bytes(claim_bytes);
    (commitment_tag, point_tag, claim128)
}

fn ivc_sangria_tags(proof: &crate::ivc_adapter::SangriaProof) -> ([u8; 32], [u8; 32], u128) {
    let receipt_hash = ivc_receipt_hash(proof.r1cs_receipt.as_ref());
    let mut commit_parts: Vec<&[u8]> = Vec::with_capacity(2 + proof.wire_commitments.len() + 1);
    commit_parts.push(crate::ivc_adapter::GLYPH_IVC_SANGRIA_COMMIT_TAG_DOMAIN);
    commit_parts.push(&receipt_hash);
    for wc in &proof.wire_commitments {
        commit_parts.push(wc);
    }
    commit_parts.push(&proof.acc_commitment);
    let commitment_tag = crate::adapters::keccak256_concat(&commit_parts);
    let point_tag = crate::adapters::keccak256_concat(&[
        crate::ivc_adapter::GLYPH_IVC_SANGRIA_POINT_TAG_DOMAIN,
        &receipt_hash,
        &proof.t_commitment,
        &proof.folding_challenge,
    ]);
    let claim_hash = crate::adapters::keccak256_concat(&[
        crate::ivc_adapter::GLYPH_IVC_SANGRIA_CLAIM_TAG_DOMAIN,
        &receipt_hash,
        &proof.folding_challenge,
    ]);
    let mut claim_bytes = [0u8; 16];
    claim_bytes.copy_from_slice(&claim_hash[..16]);
    let claim128 = u128::from_be_bytes(claim_bytes);
    (commitment_tag, point_tag, claim128)
}

fn build_ivc_calldata(
    chain_id: u64,
    contract_addr: [u8; 20],
    rounds: usize,
    proof_type: crate::adapters::IvcProofType,
    proof_bytes: &[u8],
    tags: ([u8; 32], [u8; 32], u128),
) -> Result<Vec<u8>, String> {
    use crate::glyph_gkr::encode_artifact_poly_bound_packed_calldata_be;
    use crate::glyph_gkr::prove_packed_artifact_poly_sumcheck;

    let vk_bytes = crate::adapters::ivc_vk_bytes(rounds as u8, proof_type);
    let stmt_bytes = crate::adapters::ivc_statement_bytes(
        &tags.0,
        &tags.1,
        tags.2,
        proof_type,
    );

    let ir = crate::adapter_ir::AdapterIr {
        version: 1,
        ops: vec![crate::adapter_ir::AdapterIrOp {
            kernel_id: crate::adapter_ir::kernel_id::IVC_VERIFY,
            args: Vec::new(),
        }],
    };
    let (commitment_tag, point_tag, claim128) =
        crate::adapter_ir::derive_glyph_artifact_from_ivc_ir(
            &ir.encode(),
            &vk_bytes,
            &stmt_bytes,
            proof_bytes,
        )
        .map_err(|e| format!("ivc artifact failed: {e}"))?;

    let claim = crate::glyph_gkr::gkr_canonicalize_u128(claim128);

    let proof = prove_packed_artifact_poly_sumcheck(
        &commitment_tag,
        &point_tag,
        &claim,
        chain_id,
        contract_addr,
        rounds,
    );
    Ok(encode_artifact_poly_bound_packed_calldata_be(
        &proof,
        chain_id,
        contract_addr,
        &commitment_tag,
        &point_tag,
        &claim,
        false,
    ))
}

fn build_risc0_external_receipt_json() -> Result<Vec<u8>, String> {
    let receipt = build_standard_baby_bear_receipt_fixture()?;
    let vk = crate::stark_receipt::CanonicalStarkReceipt::decode_and_validate_vk(&receipt)
        .map_err(|e| format!("vk decode failed: {e}"))?;
    let external = crate::risc_zero_bundle::RiscZeroExternalReceipt {
        version: 1,
        profile_hex: hex::encode(&vk.consts_bytes),
        program_hex: hex::encode(&vk.program_bytes),
        seal_hex: hex::encode(&receipt.proof_bytes),
        journal_hex: hex::encode(&receipt.pub_inputs_bytes),
    };
    serde_json::to_vec(&external).map_err(|e| format!("risc0 external json failed: {e}"))
}

fn ivc_opening_tags(
    opening: &crate::ivc_adapter::BaseFoldPcsOpeningProof,
) -> ([u8; 32], [u8; 32], u128) {
    use binius_field::underlier::WithUnderlier;
    use crate::pcs_basefold::{derive_basefold_commitment_tag, derive_basefold_point_tag};

    let commitment_tag = derive_basefold_commitment_tag(&opening.commitment);
    let point_tag = derive_basefold_point_tag(&commitment_tag, &opening.eval_point);
    let claim128 = opening.claimed_eval.to_underlier();
    (commitment_tag, point_tag, claim128)
}

#[cfg(feature = "ivc-supernova")]
fn supernova_solidity_tests(
    chain_id: u64,
    contract_addr: [u8; 20],
    rounds: usize,
) -> Result<String, String> {
    let supernova_proof = fake_ivc_supernova_proof()?;
    let supernova_payload = crate::ivc_adapter::encode_supernova_proof_bytes(&supernova_proof);
    let supernova_proof_bytes = crate::ivc_adapter::encode_ivc_proof_bytes(
        crate::adapters::IvcProofType::SuperNova,
        &supernova_payload,
    );
    let supernova_tags = ivc_supernova_tags(&supernova_proof);
    let supernova_calldata = build_ivc_calldata(
        chain_id,
        contract_addr,
        rounds,
        crate::adapters::IvcProofType::SuperNova,
        &supernova_proof_bytes,
        supernova_tags,
    )?;
    let supernova_hex = hex::encode(&supernova_calldata);

    Ok(format!(
        r#"
    function test_GLYPH_IVC_SuperNova_Succeeds() public {{
        bytes memory proof = hex"{supernova_hex}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_IVC_SuperNova_MetaTamper_Fails() public {{
        bytes memory proof = hex"{supernova_hex}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#,
        supernova_hex = supernova_hex
    ))
}

#[cfg(not(feature = "ivc-supernova"))]
fn supernova_solidity_tests(
    _chain_id: u64,
    _contract_addr: [u8; 20],
    _rounds: usize,
) -> Result<String, String> {
    Ok(String::new())
}

pub fn generate_glyph_ivc_solidity_test_file() -> Result<String, String> {
    let chain_id = 31337u64;
    let contract_addr = [0xeeu8; 20];
    let seed = b"glyph-ivc";
    let rounds = 5usize;

    let opening = fake_ivc_opening(seed)?;
    let basefold_payload =
        crate::ivc_adapter::encode_ivc_basefold_proof_bytes(&opening)
            .map_err(|e| format!("ivc payload failed: {e}"))?;
    let basefold_proof_bytes = crate::ivc_adapter::encode_ivc_proof_bytes(
        crate::adapters::IvcProofType::BaseFoldTransparent,
        &basefold_payload,
    );
    let basefold_tags = ivc_opening_tags(&opening);
    let basefold_calldata = build_ivc_calldata(
        chain_id,
        contract_addr,
        rounds,
        crate::adapters::IvcProofType::BaseFoldTransparent,
        &basefold_proof_bytes,
        basefold_tags,
    )?;
    let basefold_hex = hex::encode(&basefold_calldata);

    let nova_proof = fake_ivc_nova_proof()?;
    let nova_payload = crate::ivc_adapter::encode_nova_proof_bytes(&nova_proof);
    let nova_proof_bytes = crate::ivc_adapter::encode_ivc_proof_bytes(
        crate::adapters::IvcProofType::Nova,
        &nova_payload,
    );
    let nova_tags = ivc_nova_tags(&nova_proof);
    let nova_calldata = build_ivc_calldata(
        chain_id,
        contract_addr,
        rounds,
        crate::adapters::IvcProofType::Nova,
        &nova_proof_bytes,
        nova_tags,
    )?;
    let nova_hex = hex::encode(&nova_calldata);

    let supernova_block = supernova_solidity_tests(chain_id, contract_addr, rounds)?;

    let hypernova_proof = fake_ivc_hypernova_proof()?;
    let hypernova_payload = crate::ivc_adapter::encode_hypernova_proof_bytes(&hypernova_proof);
    let hypernova_proof_bytes = crate::ivc_adapter::encode_ivc_proof_bytes(
        crate::adapters::IvcProofType::HyperNova,
        &hypernova_payload,
    );
    let hypernova_tags = ivc_hypernova_tags(&hypernova_proof);
    let hypernova_calldata = build_ivc_calldata(
        chain_id,
        contract_addr,
        rounds,
        crate::adapters::IvcProofType::HyperNova,
        &hypernova_proof_bytes,
        hypernova_tags,
    )?;
    let hypernova_hex = hex::encode(&hypernova_calldata);

    let sangria_proof = fake_ivc_sangria_proof()?;
    let sangria_payload = crate::ivc_adapter::encode_sangria_proof_bytes(&sangria_proof);
    let sangria_proof_bytes = crate::ivc_adapter::encode_ivc_proof_bytes(
        crate::adapters::IvcProofType::Sangria,
        &sangria_payload,
    );
    let sangria_tags = ivc_sangria_tags(&sangria_proof);
    let sangria_calldata = build_ivc_calldata(
        chain_id,
        contract_addr,
        rounds,
        crate::adapters::IvcProofType::Sangria,
        &sangria_proof_bytes,
        sangria_tags,
    )?;
    let sangria_hex = hex::encode(&sangria_calldata);

    Ok(format!(
        r#"// SPDX-License-Identifier: MIT
// AUTO-GENERATED by GLYPH Rust Prover - DO NOT EDIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "./GLYPHVerifier.sol";

contract GLYPH_IVC_Test is Test {{
    address internal constant TARGET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function setUp() public {{
        vm.chainId({chain_id});
        GLYPHVerifier impl = new GLYPHVerifier();
        vm.etch(TARGET, address(impl).code);
    }}

    function test_GLYPH_IVC_BaseFold_Succeeds() public {{
        bytes memory proof = hex"{basefold_hex}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_IVC_BaseFold_MetaTamper_Fails() public {{
        bytes memory proof = hex"{basefold_hex}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}

    function test_GLYPH_IVC_Nova_Succeeds() public {{
        bytes memory proof = hex"{nova_hex}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_IVC_Nova_MetaTamper_Fails() public {{
        bytes memory proof = hex"{nova_hex}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}

{supernova_block}
    function test_GLYPH_IVC_HyperNova_Succeeds() public {{
        bytes memory proof = hex"{hypernova_hex}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_IVC_HyperNova_MetaTamper_Fails() public {{
        bytes memory proof = hex"{hypernova_hex}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}

    function test_GLYPH_IVC_Sangria_Succeeds() public {{
        bytes memory proof = hex"{sangria_hex}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_IVC_Sangria_MetaTamper_Fails() public {{
        bytes memory proof = hex"{sangria_hex}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
}}
"#,
        chain_id = chain_id,
        basefold_hex = basefold_hex,
        nova_hex = nova_hex,
        hypernova_hex = hypernova_hex,
        sangria_hex = sangria_hex
    ))
}

pub fn generate_glyph_snark_groth16_solidity_test_file() -> Result<String, String> {
    use crate::glyph_gkr::encode_artifact_poly_bound_packed_calldata_be;
    use crate::glyph_gkr::prove_packed_artifact_poly_sumcheck;

    let chain_id = 31337u64;
    let contract_addr = [0xeeu8; 20];
    let rounds = 5usize;

    let (raw_vk_bytes, raw_proof_bytes, raw_pub_bytes) =
        crate::snark_groth16_bn254_adapter::load_groth16_bn254_fixture_bytes()?;
    let input_layout_hash = crate::adapters::keccak256(b"snark-groth16-test-layout");
    let vk_hash = crate::adapters::keccak256(&raw_vk_bytes);
    let pub_hash = crate::adapters::keccak256(&raw_pub_bytes);
    let vk = crate::bn254_groth16::decode_groth16_vk_bytes(&raw_vk_bytes)
        .map_err(|e| format!("groth16 vk decode failed: {e}"))?;
    let beta_precomp = crate::bn254_pairing_trace::encode_g2_precomp_bytes(vk.beta_g2);
    let gamma_precomp = crate::bn254_pairing_trace::encode_g2_precomp_bytes(vk.gamma_g2);
    let delta_precomp = crate::bn254_pairing_trace::encode_g2_precomp_bytes(vk.delta_g2);
    let adapter_vk_bytes = crate::adapters::groth16_bn254_vk_bytes_g2_precomp(
        crate::adapters::SNARK_GROTH16_BN254_ID,
        &vk_hash,
        &input_layout_hash,
        &beta_precomp,
        &gamma_precomp,
        &delta_precomp,
    );
    let adapter_statement_bytes =
        crate::adapters::groth16_bn254_statement_bytes(&input_layout_hash, &pub_hash);

    let ir = crate::adapter_ir::AdapterIr {
        version: 1,
        ops: vec![crate::adapter_ir::AdapterIrOp {
            kernel_id: crate::adapter_ir::kernel_id::GROTH16_BN254_VERIFY,
            args: Vec::new(),
        }],
    };
    let (commitment_tag, point_tag, claim128) = crate::adapter_ir::derive_glyph_artifact_from_groth16_bn254_ir(
        &ir.encode(),
        &adapter_vk_bytes,
        &adapter_statement_bytes,
        &raw_vk_bytes,
        &raw_proof_bytes,
        &raw_pub_bytes,
    )
    .map_err(|e| format!("snark groth16 artifact failed: {e}"))?;

    let claim = crate::glyph_gkr::gkr_canonicalize_u128(claim128);

    let proof = prove_packed_artifact_poly_sumcheck(
        &commitment_tag,
        &point_tag,
        &claim,
        chain_id,
        contract_addr,
        rounds,
    );
    let calldata = encode_artifact_poly_bound_packed_calldata_be(
        &proof,
        chain_id,
        contract_addr,
        &commitment_tag,
        &point_tag,
        &claim,
        false,
    );
    let proof_hex = hex::encode(&calldata);

    let receipt_bls = load_fast_groth16_bls12381_receipt_fixture()?;
    let (commitment_tag_bls, point_tag_bls, claim128_bls) =
        crate::groth16_bls12381::derive_glyph_artifact_from_groth16_bls12381_receipt(
            &receipt_bls,
        )
        .map_err(|e| format!("a1 bls12381 artifact failed: {e}"))?;
    let claim_bls = crate::glyph_gkr::gkr_canonicalize_u128(claim128_bls);
    let proof_bls = prove_packed_artifact_poly_sumcheck(
        &commitment_tag_bls,
        &point_tag_bls,
        &claim_bls,
        chain_id,
        contract_addr,
        rounds,
    );
    let calldata_bls = encode_artifact_poly_bound_packed_calldata_be(
        &proof_bls,
        chain_id,
        contract_addr,
        &commitment_tag_bls,
        &point_tag_bls,
        &claim_bls,
        false,
    );
    let proof_hex_bls = hex::encode(&calldata_bls);
    let bls_tests = format!(
        r#"
    function test_GLYPH_SNARK_GROTH16_BLS12381_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_bls}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_SNARK_GROTH16_BLS12381_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_bls}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
    );

    Ok(format!(
        r#"// SPDX-License-Identifier: MIT
// AUTO-GENERATED by GLYPH Rust Prover - DO NOT EDIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "./GLYPHVerifier.sol";

contract GLYPH_SNARK_GROTH16_Test is Test {{
    address internal constant TARGET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function setUp() public {{
        vm.chainId({chain_id});
        GLYPHVerifier impl = new GLYPHVerifier();
        vm.etch(TARGET, address(impl).code);
    }}

    function test_GLYPH_SNARK_GROTH16_Succeeds() public {{
        bytes memory proof = hex"{proof_hex}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_SNARK_GROTH16_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}

{bls_tests}
}}
"#,
        chain_id = chain_id,
        proof_hex = proof_hex,
        bls_tests = bls_tests
    ))
}

pub fn generate_glyph_snark_kzg_solidity_test_file() -> Result<String, String> {
    use crate::glyph_gkr::encode_artifact_poly_bound_packed_calldata_be;
    use crate::glyph_gkr::prove_packed_artifact_poly_sumcheck;

    let chain_id = 31337u64;
    let contract_addr = [0xeeu8; 20];
    let rounds = 5usize;

    let s = Fr::from(5u64);
    let z = Fr::from(13u64);
    let coeffs = [Fr::from(3u64), Fr::from(11u64), Fr::from(7u64), Fr::from(2u64)];

    let eval_poly = |x: Fr| -> Fr {
        let mut pow = Fr::ONE;
        let mut acc = Fr::ZERO;
        for c in coeffs.iter() {
            acc += *c * pow;
            pow *= x;
        }
        acc
    };

    let y = eval_poly(z);
    let f_s = eval_poly(s);
    let denom = (s - z).inverse().ok_or_else(|| "s equals z in KZG setup".to_string())?;
    let q_s = (f_s - y) * denom;

    let g1 = G1Affine::generator();
    let g2 = G2Affine::generator();
    let g2_s = g2.mul_bigint(s.into_bigint()).into_affine();
    let commitment = g1.mul_bigint(f_s.into_bigint()).into_affine();
    let proof = g1.mul_bigint(q_s.into_bigint()).into_affine();

    let vk = crate::snark_kzg_bn254_adapter::KzgVk { g1, g2, g2_s };
    let proof_data = crate::snark_kzg_bn254_adapter::KzgProof { commitment, proof };
    let inputs = crate::snark_kzg_bn254_adapter::KzgPublicInputs { z, y };

    let vk_bytes = crate::snark_kzg_bn254_adapter::encode_kzg_vk_bytes(&vk);
    let proof_bytes = crate::snark_kzg_bn254_adapter::encode_kzg_proof_bytes(&proof_data);
    let inputs_bytes = crate::snark_kzg_bn254_adapter::encode_kzg_public_inputs_bytes(&inputs);

    let input_layout_hash = crate::adapters::keccak256(b"snark-kzg-test-layout");
    let params_hash =
        crate::adapters::keccak256(&crate::snark_kzg_bn254_adapter::encode_kzg_params_bytes(&vk));
    let inputs_hash = crate::adapters::keccak256(&inputs_bytes);
    let vk_hash = crate::adapters::keccak256(&vk_bytes);
    let g2_s_precomp = crate::bn254_pairing_trace::encode_g2_precomp_bytes(g2_s);
    let adapter_vk_bytes = crate::adapters::kzg_bn254_vk_bytes_g2s_precomp(
        crate::adapters::SNARK_KZG_PLONK_ID,
        &params_hash,
        &vk_hash,
        &input_layout_hash,
        &g2_s_precomp,
    );
    let adapter_statement_bytes =
        crate::adapters::kzg_bn254_statement_bytes(&input_layout_hash, &inputs_hash);

    let ir = crate::adapter_ir::AdapterIr {
        version: 1,
        ops: vec![crate::adapter_ir::AdapterIrOp {
            kernel_id: crate::adapter_ir::kernel_id::KZG_BN254_VERIFY,
            args: Vec::new(),
        }],
    };
    let (commitment_tag, point_tag, claim128) =
        crate::adapter_ir::derive_glyph_artifact_from_kzg_bn254_ir(
            &ir.encode(),
            &adapter_vk_bytes,
            &adapter_statement_bytes,
            &vk_bytes,
            &proof_bytes,
            &inputs_bytes,
        )
        .map_err(|e| format!("snark kzg artifact failed: {e}"))?;

    let claim = crate::glyph_gkr::gkr_canonicalize_u128(claim128);

    let proof = prove_packed_artifact_poly_sumcheck(
        &commitment_tag,
        &point_tag,
        &claim,
        chain_id,
        contract_addr,
        rounds,
    );
    let calldata = encode_artifact_poly_bound_packed_calldata_be(
        &proof,
        chain_id,
        contract_addr,
        &commitment_tag,
        &point_tag,
        &claim,
        false,
    );
    let proof_hex = hex::encode(&calldata);

    let receipt_bls = load_fast_kzg_bls12381_receipt_fixture()?;
    let (commitment_tag_bls, point_tag_bls, claim128_bls) =
        crate::kzg_bls12381::derive_glyph_artifact_from_kzg_bls12381_receipt(&receipt_bls)
            .map_err(|e| format!("snark kzg bls12381 artifact failed: {e}"))?;
    let claim_bls = crate::glyph_gkr::gkr_canonicalize_u128(claim128_bls);
    let proof_bls = prove_packed_artifact_poly_sumcheck(
        &commitment_tag_bls,
        &point_tag_bls,
        &claim_bls,
        chain_id,
        contract_addr,
        rounds,
    );
    let calldata_bls = encode_artifact_poly_bound_packed_calldata_be(
        &proof_bls,
        chain_id,
        contract_addr,
        &commitment_tag_bls,
        &point_tag_bls,
        &claim_bls,
        false,
    );
    let proof_hex_bls = hex::encode(&calldata_bls);
    let bls_tests = format!(
        r#"
    function test_GLYPH_SNARK_KZG_BLS12381_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_bls}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_SNARK_KZG_BLS12381_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_bls}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
    );

    Ok(format!(
        r#"// SPDX-License-Identifier: MIT
// AUTO-GENERATED by GLYPH Rust Prover - DO NOT EDIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "./GLYPHVerifier.sol";

contract GLYPH_SNARK_KZG_Test is Test {{
    address internal constant TARGET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function setUp() public {{
        vm.chainId({chain_id});
        GLYPHVerifier impl = new GLYPHVerifier();
        vm.etch(TARGET, address(impl).code);
    }}

    function test_GLYPH_SNARK_KZG_Succeeds() public {{
        bytes memory proof = hex"{proof_hex}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_SNARK_KZG_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}

{bls_tests}
}}
"#,
        chain_id = chain_id,
        proof_hex = proof_hex,
        bls_tests = bls_tests
    ))
}

pub fn generate_glyph_snark_ipa_solidity_test_file() -> Result<String, String> {
    use crate::ipa_adapter::{build_ipa_receipt_bn254, ipa_statement_hash_bn254};
    use crate::glyph_gkr::encode_artifact_poly_bound_packed_calldata_be;
    use crate::glyph_gkr::prove_packed_artifact_poly_sumcheck;

    let chain_id = 31337u64;
    let contract_addr = [0xeeu8; 20];
    let rounds = 5usize;

    let n = 2usize;
    let params = IPAParams::new(n);
    let prover = IPAProver { params: &params };
    let a: Vec<Fr> = vec![Fr::from(1u64), Fr::from(0u64)];
    let b: Vec<Fr> = vec![Fr::from(1u64), Fr::from(0u64)];
    let public_inputs = vec![Fr::from(1u64), Fr::from(0u64)];
    let statement_hash = ipa_statement_hash_bn254(&public_inputs);
    let (commitment, _c, proof) = prover
        .prove_optimized_with_statement(&a, &b, &statement_hash)
        .map_err(|e| format!("ipa prove failed: {e:?}"))?;

    let receipt_bytes = build_ipa_receipt_bn254(
        crate::ipa_adapter::IPA_BACKEND_HALO2,
        crate::ipa_adapter::IPA_TRANSCRIPT_GLYPH,
        n,
        &public_inputs,
        &commitment.into(),
        &proof,
    );
    let (commitment_tag, point_tag, claim128) =
        crate::ipa_adapter::derive_glyph_artifact_from_ipa_receipt(&receipt_bytes)
            .map_err(|e| format!("snark ipa artifact failed: {e}"))?;

    let claim = crate::glyph_gkr::gkr_canonicalize_u128(claim128);

    let proof = prove_packed_artifact_poly_sumcheck(
        &commitment_tag,
        &point_tag,
        &claim,
        chain_id,
        contract_addr,
        rounds,
    );
    let calldata = encode_artifact_poly_bound_packed_calldata_be(
        &proof,
        chain_id,
        contract_addr,
        &commitment_tag,
        &point_tag,
        &claim,
        false,
    );
    let proof_hex = hex::encode(&calldata);

    Ok(format!(
        r#"// SPDX-License-Identifier: MIT
// AUTO-GENERATED by GLYPH Rust Prover - DO NOT EDIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "./GLYPHVerifier.sol";

contract GLYPH_SNARK_IPA_Test is Test {{
    address internal constant TARGET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function setUp() public {{
        vm.chainId({chain_id});
        GLYPHVerifier impl = new GLYPHVerifier();
        vm.etch(TARGET, address(impl).code);
    }}

    function test_GLYPH_SNARK_IPA_Succeeds() public {{
        bytes memory proof = hex"{proof_hex}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_SNARK_IPA_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
}}
"#,
        chain_id = chain_id,
        proof_hex = proof_hex
    ))
}

pub fn generate_glyph_snark_sp1_solidity_test_file() -> Result<String, String> {
    use crate::glyph_gkr::encode_artifact_poly_bound_packed_calldata_be;
    use crate::glyph_gkr::prove_packed_artifact_poly_sumcheck;

    let chain_id = 31337u64;
    let contract_addr = [0xeeu8; 20];
    let rounds = 5usize;

    let groth16_receipt_bytes =
        load_sp1_receipt_fixture("scripts/tools/fixtures/sp1_groth16_receipt.txt")?
            .ok_or_else(|| "sp1 groth16 fixture missing".to_string())?;
    let (groth16_commitment_tag, groth16_point_tag, groth16_claim128) =
        crate::sp1_adapter::derive_glyph_artifact_from_sp1_receipt(&groth16_receipt_bytes)
            .map_err(|e| format!("sp1 groth16 artifact failed: {e}"))?;

    let groth16_claim =
        crate::glyph_gkr::gkr_canonicalize_u128(groth16_claim128);

    let groth16_proof = prove_packed_artifact_poly_sumcheck(
        &groth16_commitment_tag,
        &groth16_point_tag,
        &groth16_claim,
        chain_id,
        contract_addr,
        rounds,
    );
    let groth16_calldata = encode_artifact_poly_bound_packed_calldata_be(
        &groth16_proof,
        chain_id,
        contract_addr,
        &groth16_commitment_tag,
        &groth16_point_tag,
        &groth16_claim,
        false,
    );
    let groth16_proof_hex = hex::encode(&groth16_calldata);

    let groth16_tests = format!(
        r#"
    function test_GLYPH_SNARK_SP1_Groth16_Succeeds() public {{
        bytes memory proof = hex"{groth16_proof_hex}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_SNARK_SP1_Groth16_MetaTamper_Fails() public {{
        bytes memory proof = hex"{groth16_proof_hex}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#,
    );

    let plonk_tests = if let Some(plonk_receipt_bytes) =
        load_sp1_receipt_fixture("scripts/tools/fixtures/sp1_plonk_receipt.txt")?
    {
        let (plonk_commitment_tag, plonk_point_tag, plonk_claim128) =
            crate::sp1_adapter::derive_glyph_artifact_from_sp1_receipt(&plonk_receipt_bytes)
                .map_err(|e| format!("sp1 plonk artifact failed: {e}"))?;
        let plonk_claim =
            crate::glyph_gkr::gkr_canonicalize_u128(plonk_claim128);
        let plonk_proof = prove_packed_artifact_poly_sumcheck(
            &plonk_commitment_tag,
            &plonk_point_tag,
            &plonk_claim,
            chain_id,
            contract_addr,
            rounds,
        );
        let plonk_calldata = encode_artifact_poly_bound_packed_calldata_be(
            &plonk_proof,
            chain_id,
            contract_addr,
            &plonk_commitment_tag,
            &plonk_point_tag,
            &plonk_claim,
            false,
        );
        let plonk_proof_hex = hex::encode(&plonk_calldata);
        format!(
            r#"
    function test_GLYPH_SNARK_SP1_Plonk_Succeeds() public {{
        bytes memory proof = hex"{plonk_proof_hex}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_SNARK_SP1_Plonk_MetaTamper_Fails() public {{
        bytes memory proof = hex"{plonk_proof_hex}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#,
        )
    } else {
        String::new()
    };

    Ok(format!(
        r#"// SPDX-License-Identifier: MIT
// AUTO-GENERATED by GLYPH Rust Prover - DO NOT EDIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "./GLYPHVerifier.sol";

contract GLYPH_SNARK_SP1_Test is Test {{
    address internal constant TARGET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function setUp() public {{
        vm.chainId({chain_id});
        GLYPHVerifier impl = new GLYPHVerifier();
        vm.etch(TARGET, address(impl).code);
    }}

{groth16_tests}

{plonk_tests}
}}
"#,
        chain_id = chain_id,
        groth16_tests = groth16_tests,
        plonk_tests = plonk_tests
    ))
}

pub fn generate_glyph_snark_plonk_solidity_test_file() -> Result<String, String> {
    use crate::glyph_gkr::encode_artifact_poly_bound_packed_calldata_be;
    use crate::glyph_gkr::prove_packed_artifact_poly_sumcheck;

    let chain_id = 31337u64;
    let contract_addr = [0xeeu8; 20];
    let rounds = 5usize;

    let receipt_bytes = load_or_build_plonk_bls_receipt_fixture(
        "scripts/tools/fixtures/plonk_bls12381_receipt.txt",
    )?;
    let (commitment_tag, point_tag, claim128) =
        crate::plonk_adapter::derive_glyph_artifact_from_plonk_receipt(&receipt_bytes)
            .map_err(|e| format!("plonk artifact failed: {e}"))?;

    let claim = crate::glyph_gkr::gkr_canonicalize_u128(claim128);

    let proof = prove_packed_artifact_poly_sumcheck(
        &commitment_tag,
        &point_tag,
        &claim,
        chain_id,
        contract_addr,
        rounds,
    );
    let calldata = encode_artifact_poly_bound_packed_calldata_be(
        &proof,
        chain_id,
        contract_addr,
        &commitment_tag,
        &point_tag,
        &claim,
        false,
    );
    let proof_hex = hex::encode(&calldata);

    let halo2_bn254_receipt_bytes = load_or_build_halo2_receipt_fixture(
        "scripts/tools/fixtures/halo2_bn254_kzg_receipt.txt",
        build_halo2_kzg_receipt_bn256,
    )?;
    let (halo2_bn_commitment_tag, halo2_bn_point_tag, halo2_bn_claim128) =
        crate::plonk_halo2_adapter::derive_glyph_artifact_from_plonk_halo2_receipt(
            &halo2_bn254_receipt_bytes,
        )
        .map_err(|e| format!("halo2 bn254 artifact failed: {e}"))?;
    let halo2_bn_claim =
        crate::glyph_gkr::gkr_canonicalize_u128(halo2_bn_claim128);
    let halo2_bn_proof = prove_packed_artifact_poly_sumcheck(
        &halo2_bn_commitment_tag,
        &halo2_bn_point_tag,
        &halo2_bn_claim,
        chain_id,
        contract_addr,
        rounds,
    );
    let halo2_bn_calldata = encode_artifact_poly_bound_packed_calldata_be(
        &halo2_bn_proof,
        chain_id,
        contract_addr,
        &halo2_bn_commitment_tag,
        &halo2_bn_point_tag,
        &halo2_bn_claim,
        false,
    );
    let halo2_bn_proof_hex = hex::encode(&halo2_bn_calldata);
    let halo2_bn254_tests = format!(
        r#"
    function test_GLYPH_SNARK_HALO2_BN254_Succeeds() public {{
        bytes memory proof = hex"{halo2_bn_proof_hex}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_SNARK_HALO2_BN254_MetaTamper_Fails() public {{
        bytes memory proof = hex"{halo2_bn_proof_hex}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
    );

    let halo2_bls_receipt_bytes = load_or_build_halo2_receipt_fixture(
        "scripts/tools/fixtures/halo2_bls12381_kzg_receipt.txt",
        build_halo2_kzg_receipt_bls12381,
    )?;
    let (halo2_bls_commitment_tag, halo2_bls_point_tag, halo2_bls_claim128) =
        crate::plonk_halo2_adapter::derive_glyph_artifact_from_plonk_halo2_receipt(
            &halo2_bls_receipt_bytes,
        )
        .map_err(|e| format!("halo2 bls12381 artifact failed: {e}"))?;
    let halo2_bls_claim =
        crate::glyph_gkr::gkr_canonicalize_u128(halo2_bls_claim128);
    let halo2_bls_proof = prove_packed_artifact_poly_sumcheck(
        &halo2_bls_commitment_tag,
        &halo2_bls_point_tag,
        &halo2_bls_claim,
        chain_id,
        contract_addr,
        rounds,
    );
    let halo2_bls_calldata = encode_artifact_poly_bound_packed_calldata_be(
        &halo2_bls_proof,
        chain_id,
        contract_addr,
        &halo2_bls_commitment_tag,
        &halo2_bls_point_tag,
        &halo2_bls_claim,
        false,
    );
    let halo2_bls_proof_hex = hex::encode(&halo2_bls_calldata);
    let halo2_bls_tests = format!(
        r#"
    function test_GLYPH_SNARK_HALO2_BLS12381_Succeeds() public {{
        bytes memory proof = hex"{halo2_bls_proof_hex}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_SNARK_HALO2_BLS12381_MetaTamper_Fails() public {{
        bytes memory proof = hex"{halo2_bls_proof_hex}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
    );

    let bn254_tests = if let Some(bn_receipt_bytes) = load_plonk_bn254_gnark_receipt_fixture()? {
        let (bn_commitment_tag, bn_point_tag, bn_claim128) =
            crate::plonk_adapter::derive_glyph_artifact_from_plonk_receipt(&bn_receipt_bytes)
                .map_err(|e| format!("plonk bn254 artifact failed: {e}"))?;
        let bn_claim = crate::glyph_gkr::gkr_canonicalize_u128(bn_claim128);
        let bn_proof = prove_packed_artifact_poly_sumcheck(
            &bn_commitment_tag,
            &bn_point_tag,
            &bn_claim,
            chain_id,
            contract_addr,
            rounds,
        );
        let bn_calldata = encode_artifact_poly_bound_packed_calldata_be(
            &bn_proof,
            chain_id,
            contract_addr,
            &bn_commitment_tag,
            &bn_point_tag,
            &bn_claim,
            false,
        );
        let bn_proof_hex = hex::encode(&bn_calldata);
        format!(
            r#"
    function test_GLYPH_SNARK_PLONK_BN254_Succeeds() public {{
        bytes memory proof = hex"{bn_proof_hex}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_SNARK_PLONK_BN254_MetaTamper_Fails() public {{
        bytes memory proof = hex"{bn_proof_hex}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
"#
        )
    } else {
        String::new()
    };

    Ok(format!(
        r#"// SPDX-License-Identifier: MIT
// AUTO-GENERATED by GLYPH Rust Prover - DO NOT EDIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "./GLYPHVerifier.sol";

contract GLYPH_SNARK_PLONK_Test is Test {{
    address internal constant TARGET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function setUp() public {{
        vm.chainId({chain_id});
        GLYPHVerifier impl = new GLYPHVerifier();
        vm.etch(TARGET, address(impl).code);
    }}

    function test_GLYPH_SNARK_PLONK_Succeeds() public {{
        bytes memory proof = hex"{proof_hex}";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPH_SNARK_PLONK_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex}";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}
{bn254_tests}
{halo2_bn254_tests}
{halo2_bls_tests}
}}
"#,
        chain_id = chain_id,
        proof_hex = proof_hex,
        bn254_tests = bn254_tests,
        halo2_bn254_tests = halo2_bn254_tests,
        halo2_bls_tests = halo2_bls_tests
    ))
}

/// Generate GLYPHVerifierTest.t.sol with packed calldata vectors.
pub fn generate_glyph_verifier_solidity_test_file() -> String {
    use crate::glyph_gkr::encode_artifact_poly_bound_packed_calldata_be;
    use crate::glyph_gkr::gkr_canonicalize_u128;
    use crate::glyph_gkr::prove_packed_artifact_poly_sumcheck;

    let chain_id = 31337u64;
    let contract_addr = [0xeeu8; 20];
    let rounds = 5usize;

    // Generate deterministic test data
    let commitment_tag = crate::adapters::keccak256(b"glyph-verifier-test-commitment");
    let point_tag = crate::adapters::keccak256(b"glyph-verifier-test-point");
    let claim128: u128 = 123u128; // Small claim for testing
    let claim = gkr_canonicalize_u128(claim128);

    // Generate proof (packed-128 layout, 32 bytes per round)
    let proof_full = prove_packed_artifact_poly_sumcheck(
        &commitment_tag,
        &point_tag,
        &claim,
        chain_id,
        contract_addr,
        rounds,
    );
    let calldata_full = encode_artifact_poly_bound_packed_calldata_be(
        &proof_full,
        chain_id,
        contract_addr,
        &commitment_tag,
        &point_tag,
        &claim,
        false,
    );
    let proof_hex_full = hex::encode(&calldata_full);

    // Generate alternate vector. Packed-128 uses the same payload for truncated.
    let calldata_truncated = encode_artifact_poly_bound_packed_calldata_be(
        &proof_full,
        chain_id,
        contract_addr,
        &commitment_tag,
        &point_tag,
        &claim,
        true,
    );
    let proof_hex_truncated = hex::encode(&calldata_truncated);

    format!(
        r#"// SPDX-License-Identifier: MIT
// AUTO-GENERATED by GLYPH Rust Prover - DO NOT EDIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "./GLYPHVerifier.sol";

/**
 * @title GLYPHVerifierTest
 * @notice Packed calldata verification vectors.
 *
 * Note: Packed-128 has no distinct truncated payload. The truncated vector is
 * intentionally identical to full and still exercises the same on-chain path.
 */
contract GLYPHVerifierTest is Test {{
    address internal constant TARGET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function setUp() public {{
        vm.chainId({chain_id});

        GLYPHVerifier impl = new GLYPHVerifier();
        vm.etch(TARGET, address(impl).code);
    }}

    function test_GLYPHVerifier_VerifyPacked_Bound_Full_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_full}";

        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "bound full verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPHVerifier_VerifyPacked_Bound_Truncated_Succeeds() public {{
        bytes memory proof = hex"{proof_hex_truncated}";

        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "bound truncated verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }}

    function test_GLYPHVerifier_VerifyPacked_Bound_MetaTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_full}";

        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }}

    function test_GLYPHVerifier_VerifyPacked_Bound_ClaimHighBits_Fails() public {{
        bytes memory proof = hex"{proof_hex_full}";

        // Upper 128 bits of claim (byte 96..111) must be zero.
        proof[96] = bytes1(uint8(proof[96]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "claim high bits must revert");
    }}

    function test_GLYPHVerifier_VerifyPacked_Bound_ClaimTamper_Fails() public {{
        bytes memory proof = hex"{proof_hex_full}";

        proof[127] = bytes1(uint8(proof[127]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "claim tamper must revert");
    }}
}}
"#,
        chain_id = chain_id,
        proof_hex_full = proof_hex_full,
        proof_hex_truncated = proof_hex_truncated
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    fn build_stark_f64_canonical_receipt() -> Result<crate::stark_receipt::CanonicalStarkReceipt, String> {
        use winterfell::{BatchingMethod, FieldExtension, ProofOptions, Prover};
        use crate::stark_winterfell::StarkUpstreamReceipt;
        use crate::stark_winterfell_f64::{
            DoWorkProverSha3F64, build_do_work_trace, public_inputs_bytes,
            vk_params_bytes_sha3_canonical, verify_do_work_sha3,
            canonical_stark_receipt_from_upstream_do_work,
        };
        use winterfell::math::fields::f64::BaseElement;

        let start = BaseElement::new(7);
        let candidates = [
            (128usize, ProofOptions::new(64, 16, 0, FieldExtension::Quadratic, 8, 31, BatchingMethod::Linear, BatchingMethod::Linear)),
            (256usize, ProofOptions::new(64, 16, 0, FieldExtension::Quadratic, 8, 31, BatchingMethod::Linear, BatchingMethod::Linear)),
            (256usize, ProofOptions::new(96, 16, 0, FieldExtension::Quadratic, 8, 31, BatchingMethod::Linear, BatchingMethod::Linear)),
        ];

        for (trace_length, options) in candidates {
            let trace = build_do_work_trace(start, trace_length);
            let prover = DoWorkProverSha3F64::new(options.clone());
            let pub_inputs = prover.get_pub_inputs(&trace);
            let proof = prover
                .prove(trace)
                .map_err(|e| format!("f64 prove failed: {e:?}"))?;
            let proof_bytes = proof.to_bytes();

            if verify_do_work_sha3(proof, pub_inputs).is_err() {
                continue;
            }

            let receipt = StarkUpstreamReceipt {
                proof_bytes,
                pub_inputs_bytes: public_inputs_bytes(&pub_inputs),
                vk_params_bytes: vk_params_bytes_sha3_canonical(1, trace_length, &options),
            };
            return canonical_stark_receipt_from_upstream_do_work(&receipt);
        }

        Err("no f64 proof met the min security threshold".to_string())
    }

    #[test]
    fn test_stark_f64_receipt_to_glyph_artifact_verify() -> Result<(), String> {
        use crate::glyph_core::{prove_compiled, ProverConfig};
        use crate::glyph_ir_compiler::compile_stark;
        use crate::glyph_gkr::verify_artifact_poly_packed_calldata_be;

        let receipt = build_stark_f64_canonical_receipt()?;
        let receipt_bytes = receipt.encode_for_hash();
        let seed = b"glyph-stark-f64-e2e";
        let compiled = compile_stark(&receipt_bytes, seed)
            .map_err(|e| format!("compile stark f64: {e:?}"))?;

        let chain_id = 31337u64;
        let contract_addr = [0xeeu8; 20];
        let config = ProverConfig {
            chainid: Some(chain_id),
            contract_addr: Some(contract_addr),
            gkr_truncated: true,
            ..Default::default()
        };

        let proof = prove_compiled(compiled, config)
            .map_err(|e| format!("prove stark f64: {e:?}"))?;
        assert!(!proof.packed_gkr_calldata.is_empty());
        assert!(
            verify_artifact_poly_packed_calldata_be(&proof.packed_gkr_calldata, chain_id, contract_addr),
            "packed calldata must verify"
        );
        Ok(())
    }

    #[test]
    fn test_stark_circle_large_receipt_to_glyph_artifact_verify() -> Result<(), String> {
        use crate::glyph_core::{prove_compiled, ProverConfig};
        use crate::glyph_ir_compiler::compile_stark;
        use crate::glyph_gkr::verify_artifact_poly_packed_calldata_be;

        let receipt = load_fast_circle_receipt_fixture_large()?;
        let receipt_bytes = receipt.encode_for_hash();
        let seed = b"glyph-stark-circle-large-e2e";
        let compiled = compile_stark(&receipt_bytes, seed)
            .map_err(|e| format!("compile stark circle large: {e:?}"))?;

        let chain_id = 31337u64;
        let contract_addr = [0xeeu8; 20];
        let config = ProverConfig {
            chainid: Some(chain_id),
            contract_addr: Some(contract_addr),
            gkr_truncated: true,
            ..Default::default()
        };

        let proof = prove_compiled(compiled, config)
            .map_err(|e| format!("prove stark circle large: {e:?}"))?;
        assert!(!proof.packed_gkr_calldata.is_empty());
        assert!(
            verify_artifact_poly_packed_calldata_be(&proof.packed_gkr_calldata, chain_id, contract_addr),
            "packed calldata must verify"
        );
        Ok(())
    }

    #[test]
    fn test_stark_standard_baby_bear_receipt_to_glyph_artifact_verify() -> Result<(), String> {
        use crate::glyph_core::{prove_compiled, ProverConfig};
        use crate::glyph_ir_compiler::compile_stark;
        use crate::glyph_gkr::verify_artifact_poly_packed_calldata_be;

        let receipt = build_standard_baby_bear_receipt_fixture()?;
        let receipt_bytes = receipt.encode_for_hash();
        let seed = b"glyph-stark-babybear-standard-e2e";
        let compiled = compile_stark(&receipt_bytes, seed)
            .map_err(|e| format!("compile stark babybear std: {e:?}"))?;

        let chain_id = 31337u64;
        let contract_addr = [0xeeu8; 20];
        let config = ProverConfig {
            chainid: Some(chain_id),
            contract_addr: Some(contract_addr),
            gkr_truncated: true,
            ..Default::default()
        };

        let proof = prove_compiled(compiled, config)
            .map_err(|e| format!("prove stark babybear std: {e:?}"))?;
        assert!(!proof.packed_gkr_calldata.is_empty());
        assert!(
            verify_artifact_poly_packed_calldata_be(&proof.packed_gkr_calldata, chain_id, contract_addr),
            "packed calldata must verify"
        );
        Ok(())
    }

    #[test]
    fn test_stark_risc0_external_receipt_to_glyph_artifact_verify() -> Result<(), String> {
        use crate::glyph_core::{prove_compiled, ProverConfig};
        use crate::glyph_ir_compiler::compile_stark;
        use crate::glyph_gkr::verify_artifact_poly_packed_calldata_be;
        use crate::risc_zero_bundle::{decode_risc_zero_receipt_input, RiscZeroReceiptInput};

        let json = build_risc0_external_receipt_json()
            .map_err(|e| format!("risc0 external json: {e}"))?;
        let input = decode_risc_zero_receipt_input(&json)
            .map_err(|e| format!("decode: {e}"))?;
        let (receipt, program) = match input {
            RiscZeroReceiptInput::External(receipt) => receipt
                .into_receipt_and_program()
                .map_err(|e| format!("receipt: {e}"))?,
            RiscZeroReceiptInput::Bundle(bundle) => bundle
                .into_receipt_and_program()
                .map_err(|e| format!("bundle: {e}"))?,
        };
        let decoded_vk =
            crate::stark_receipt::CanonicalStarkReceipt::decode_and_validate_vk(&receipt)
                .map_err(|e| format!("vk decode: {e}"))?;
        crate::standard_stark::verify_standard_stark_receipt(&receipt, &decoded_vk, &program)
            .map_err(|e| format!("standard verify: {e}"))?;

        let receipt_bytes = receipt.encode_for_hash();
        let seed = b"glyph-stark-risc0-external-e2e";
        let compiled = compile_stark(&receipt_bytes, seed)
            .map_err(|e| format!("compile stark risc0 external: {e:?}"))?;

        let chain_id = 31337u64;
        let contract_addr = [0xeeu8; 20];
        let config = ProverConfig {
            chainid: Some(chain_id),
            contract_addr: Some(contract_addr),
            gkr_truncated: true,
            ..Default::default()
        };

        let proof = prove_compiled(compiled, config)
            .map_err(|e| format!("prove stark risc0 external: {e:?}"))?;
        assert!(!proof.packed_gkr_calldata.is_empty());
        assert!(
            verify_artifact_poly_packed_calldata_be(&proof.packed_gkr_calldata, chain_id, contract_addr),
            "packed calldata must verify"
        );
        Ok(())
    }

    fn check_or_update_snapshot(path: &str, content: &str) -> Result<(), String> {
        let update = std::env::var("UPDATE_SNAPSHOTS")
            .map(|v| v == "1" || v.eq_ignore_ascii_case("true"))
            .unwrap_or(false);

        if std::path::Path::new(path).exists() {
            let existing =
                std::fs::read_to_string(path).map_err(|e| format!("read snapshot: {e}"))?;
            if existing == content {
                println!("Snapshot matches: {}", path);
                return Ok(());
            }
            if !update {
                return Err(format!(
                    "Snapshot mismatch for {path}. Run UPDATE_SNAPSHOTS=1 to accept changes. Diff length: existing={} vs new={}",
                    existing.len(),
                    content.len()
                ));
            }
        }

        if let Some(parent) = std::path::Path::new(path).parent() {
            std::fs::create_dir_all(parent)
                .map_err(|e| format!("create snapshot dir: {e}"))?;
        }
        std::fs::write(path, content).map_err(|e| format!("write snapshot: {e}"))?;
        println!("Updated snapshot: {}", path);
        Ok(())
    }

    #[test]
    fn test_export_solidity_tests() -> Result<(), String> {
        let solidity_code = generate_solidity_test_file()
            .map_err(|e| format!("generate solidity test: {e}"))?;
        
        println!("\n=== GENERATED SOLIDITY TEST FILE ===\n");
        println!("{}", &solidity_code[..2000.min(solidity_code.len())]);
        println!("...[truncated]...\n");
        println!("Total size: {} bytes", solidity_code.len());
        
        // Write to file for actual use
        // Changed filename to .t.sol to ensure Foundry picks it up
        check_or_update_snapshot(
            "scripts/tests/foundry/GeneratedRealProofTest.t.sol",
            &solidity_code,
        )?;
        Ok(())
    }

    #[test]
    fn test_export_glyph_stark_vectors() -> Result<(), String> {
        let solidity_code =
            generate_glyph_stark_solidity_test_file().map_err(|e| format!("generate stark vectors: {e}"))?;

        check_or_update_snapshot(
            "scripts/tests/foundry/GLYPH_STARK_Test.t.sol",
            &solidity_code,
        )?;
        Ok(())
    }

    #[test]
    fn test_export_glyph_hash_merge_vectors() -> Result<(), String> {
        let _env_lock = crate::test_utils::lock_env();
        let solidity_code =
            generate_glyph_hash_merge_solidity_test_file().map_err(|e| format!("generate hash merge vectors: {e}"))?;

        check_or_update_snapshot(
            "scripts/tests/foundry/GLYPH_HASH_Test.t.sol",
            &solidity_code,
        )?;
        Ok(())
    }

    #[test]
    fn test_export_glyph_ivc_vectors() -> Result<(), String> {
        let _env_lock = crate::test_utils::lock_env();
        let solidity_code =
            generate_glyph_ivc_solidity_test_file().map_err(|e| format!("generate ivc vectors: {e}"))?;

        check_or_update_snapshot(
            "scripts/tests/foundry/GLYPH_IVC_Test.t.sol",
            &solidity_code,
        )?;
        Ok(())
    }

    #[test]
    fn test_export_glyph_snark_groth16_vectors() -> Result<(), String> {
        let _env_lock = crate::test_utils::lock_env();
        let solidity_code =
            generate_glyph_snark_groth16_solidity_test_file().map_err(|e| format!("groth16 solidity test: {e}"))?;

        check_or_update_snapshot(
            "scripts/tests/foundry/GLYPH_SNARK_GROTH16_Test.t.sol",
            &solidity_code,
        )?;
        Ok(())
    }

    #[test]
    fn test_export_glyph_snark_kzg_vectors() -> Result<(), String> {
        let _env_lock = crate::test_utils::lock_env();
        let solidity_code =
            generate_glyph_snark_kzg_solidity_test_file().map_err(|e| format!("generate kzg vectors: {e}"))?;

        check_or_update_snapshot(
            "scripts/tests/foundry/GLYPH_SNARK_KZG_Test.t.sol",
            &solidity_code,
        )?;
        Ok(())
    }

    #[test]
    fn test_export_glyph_snark_ipa_vectors() -> Result<(), String> {
        let solidity_code =
            generate_glyph_snark_ipa_solidity_test_file().map_err(|e| format!("generate ipa vectors: {e}"))?;

        check_or_update_snapshot(
            "scripts/tests/foundry/GLYPH_SNARK_IPA_Test.t.sol",
            &solidity_code,
        )?;
        Ok(())
    }

    #[test]
    fn test_export_glyph_snark_sp1_vectors() -> Result<(), String> {
        let include_sp1 = std::env::var("GLYPH_E2E_INCLUDE_SP1")
            .ok()
            .map(|v| v == "1" || v.eq_ignore_ascii_case("true"))
            .unwrap_or(false);
        if !include_sp1 {
            eprintln!("Skipping SNARK SP1 export (GLYPH_E2E_INCLUDE_SP1=0)");
            return Ok(());
        }
        if !std::path::Path::new("scripts/tools/fixtures/sp1_groth16_receipt.txt").exists()
            && !std::path::Path::new("scripts/tools/fixtures/sp1_groth16_receipt.txt.candidate").exists()
        {
            eprintln!("Skipping SNARK SP1 export (fixture missing)");
            return Ok(());
        }

        let solidity_code =
            generate_glyph_snark_sp1_solidity_test_file().map_err(|e| format!("generate sp1 vectors: {e}"))?;

        check_or_update_snapshot(
            "scripts/tests/foundry/GLYPH_SNARK_SP1_Test.t.sol",
            &solidity_code,
        )?;
        Ok(())
    }

    #[test]
    fn test_export_glyph_snark_plonk_vectors() -> Result<(), String> {
        let solidity_code =
            generate_glyph_snark_plonk_solidity_test_file().map_err(|e| format!("generate plonk vectors: {e}"))?;

        check_or_update_snapshot(
            "scripts/tests/foundry/GLYPH_SNARK_PLONK_Test.t.sol",
            &solidity_code,
        )?;
        Ok(())
    }

    #[test]
    fn test_export_glyph_verifier_vectors() -> Result<(), String> {
        let solidity_code = generate_glyph_verifier_solidity_test_file();

        check_or_update_snapshot(
            "scripts/tests/foundry/GLYPHVerifierTest.t.sol",
            &solidity_code,
        )?;
        Ok(())
    }

    #[test]
    fn test_ivc_tamper_rejects() -> Result<(), String> {
        let opening = fake_ivc_opening(b"glyph-ivc-tamper")
            .map_err(|e| format!("ivc opening: {e}"))?;
        let payload = crate::ivc_adapter::encode_ivc_basefold_proof_bytes(&opening)
            .map_err(|e| format!("ivc payload: {e}"))?;
        let proof_bytes = crate::ivc_adapter::encode_ivc_proof_bytes(
            crate::adapters::IvcProofType::BaseFoldTransparent,
            &payload,
        );
        let (commitment_tag, point_tag, claim128) = ivc_opening_tags(&opening);
        let vk_bytes = crate::adapters::ivc_vk_bytes(
            5,
            crate::adapters::IvcProofType::BaseFoldTransparent,
        );
        let stmt_bytes = crate::adapters::ivc_statement_bytes(
            &commitment_tag,
            &point_tag,
            claim128,
            crate::adapters::IvcProofType::BaseFoldTransparent,
        );

        let mut tampered = proof_bytes.clone();
        let last = tampered.len() - 1;
        tampered[last] ^= 1;
        let ir = crate::adapter_ir::AdapterIr {
            version: 1,
            ops: vec![crate::adapter_ir::AdapterIrOp {
                kernel_id: crate::adapter_ir::kernel_id::IVC_VERIFY,
                args: Vec::new(),
            }],
        };
        assert!(crate::adapter_ir::derive_glyph_artifact_from_ivc_ir(
            &ir.encode(),
            &vk_bytes,
            &stmt_bytes,
            &tampered,
        )
        .is_err());
        Ok(())
    }
    
}
