#!/usr/bin/env python3
import re
import sys
from pathlib import Path


RC = [
    0x0000000000000001,
    0x0000000000008082,
    0x800000000000808A,
    0x8000000080008000,
    0x000000000000808B,
    0x0000000080000001,
    0x8000000080008081,
    0x8000000000008009,
    0x000000000000008A,
    0x0000000000000088,
    0x0000000080008009,
    0x000000008000000A,
    0x000000008000808B,
    0x800000000000008B,
    0x8000000000008089,
    0x8000000000008003,
    0x8000000000008002,
    0x8000000000000080,
    0x000000000000800A,
    0x800000008000000A,
    0x8000000080008081,
    0x8000000000008080,
    0x0000000080000001,
    0x8000000080008008,
]

ROT = [
    [0, 36, 3, 41, 18],
    [1, 44, 10, 45, 2],
    [62, 6, 43, 15, 61],
    [28, 55, 25, 21, 56],
    [27, 20, 39, 8, 14],
]


def rotl(x, n):
    return ((x << n) | (x >> (64 - n))) & 0xFFFFFFFFFFFFFFFF


def keccak_f(state):
    for rc in RC:
        c = [state[x] ^ state[x + 5] ^ state[x + 10] ^ state[x + 15] ^ state[x + 20] for x in range(5)]
        d = [c[(x - 1) % 5] ^ rotl(c[(x + 1) % 5], 1) for x in range(5)]
        for x in range(5):
            for y in range(5):
                state[x + 5 * y] ^= d[x]
        b = [0] * 25
        for x in range(5):
            for y in range(5):
                b[y + 5 * ((2 * x + 3 * y) % 5)] = rotl(state[x + 5 * y], ROT[x][y])
        for x in range(5):
            for y in range(5):
                state[x + 5 * y] = b[x + 5 * y] ^ ((~b[((x + 1) % 5) + 5 * y]) & b[((x + 2) % 5) + 5 * y])
        state[0] ^= rc


def keccak256(data):
    rate = 136
    state = [0] * 25
    pad_len = rate - ((len(data) + 1) % rate)
    padded = data + b"\x01" + (b"\x00" * pad_len) + b"\x80"
    for i in range(0, len(padded), rate):
        block = padded[i:i + rate]
        for j in range(rate // 8):
            chunk = int.from_bytes(block[j * 8:(j + 1) * 8], "little")
            state[j] ^= chunk
        keccak_f(state)
    out = b"".join(state[i].to_bytes(8, "little") for i in range(rate // 8))
    return out[:32]


def extract_const(text, name):
    match = re.search(rf"{name}\\s*:\\s*u128\\s*=\\s*([0-9]+);", text)
    if not match:
        raise ValueError(f"Missing {name} in glyph_gkr.rs")
    return int(match.group(1))


def extract_domain(text, name):
    match = re.search(rf"{name}\\s*:\\s*&\\[u8\\]\\s*=\\s*b\\\"([^\\\"]+)\\\";", text)
    if not match:
        raise ValueError(f"Missing {name} in glyph_gkr.rs")
    return match.group(1).encode("ascii")


def render_solidity(modulus, inv140, lin_domain_hex):
    return "\n".join(
        [
            "// SPDX-License-Identifier: MIT",
            "pragma solidity ^0.8.20;",
            "",
            "// Generated by scripts/tools/generate_glyph_verifier_constants.py. Do not edit by hand.",
            "abstract contract GLYPHVerifierConstants {",
            f"    uint256 internal constant MODULUS = {modulus};",
            f"    uint256 internal constant INV140 = {inv140};",
            f"    bytes32 internal constant LIN_DOMAIN = 0x{lin_domain_hex};",
            "}",
            "",
        ]
    )


def main():
    root = Path(__file__).resolve().parents[2]
    rust_path = root / "src" / "glyph_gkr.rs"
    text = rust_path.read_text(encoding="utf-8")
    modulus = extract_const(text, "GKR_MODULUS")
    inv140 = extract_const(text, "GKR_INV140")
    domain = extract_domain(text, "GLYPH_GKR_ARTIFACT_LIN_DOMAIN")
    lin_hash = keccak256(domain).hex()
    sol = render_solidity(modulus, inv140, lin_hash)
    targets = [
        root / "contracts" / "GLYPHVerifierConstants.sol",
        root / "scripts" / "tests" / "foundry" / "GLYPHVerifierConstants.sol",
    ]
    for target in targets:
        target.write_text(sol, encoding="utf-8")
    print("Wrote:")
    for target in targets:
        print(f"- {target}")


if __name__ == "__main__":
    main()
