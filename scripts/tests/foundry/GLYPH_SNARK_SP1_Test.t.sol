// SPDX-License-Identifier: MIT
// AUTO-GENERATED by GLYPH Rust Prover - DO NOT EDIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "./GLYPHVerifier.sol";

contract GLYPH_SNARK_SP1_Test is Test {
    address internal constant TARGET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function setUp() public {
        vm.chainId(31337);
        GLYPHVerifier impl = new GLYPHVerifier();
        vm.etch(TARGET, address(impl).code);
    }


    function test_GLYPH_SNARK_SP1_Groth16_Succeeds() public {
        bytes memory proof = hex"c8f393731ff25b6cd64c234bee4a3aec179a98a0e20117067fba4772263ac07d4d6c5d4e9f050491a44e040f836ad60d24273b0329e56773bde8c78c8099e46dd8de7947c4ca99755f7d6e99638d13238102b251b49f971b8dacb36d07f784e2543aa49b5e060bfa797a0f429e94c352f4c60fc4545fc74e2944421ec9e47326cfc35e431c2f1c87be9d4cea66aa252bce3cbf9e0747d4abbc0557b35b298c7331381778311a251bac1b959541c918cec4b2145bc731da7190c7082fc890ae83678e8f5b956428d1d97a06012f1eec1bde103adc7d9d3e39875291c5f0c7023b";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }

    function test_GLYPH_SNARK_SP1_Groth16_MetaTamper_Fails() public {
        bytes memory proof = hex"c8f393731ff25b6cd64c234bee4a3aec179a98a0e20117067fba4772263ac07d4d6c5d4e9f050491a44e040f836ad60d24273b0329e56773bde8c78c8099e46dd8de7947c4ca99755f7d6e99638d13238102b251b49f971b8dacb36d07f784e2543aa49b5e060bfa797a0f429e94c352f4c60fc4545fc74e2944421ec9e47326cfc35e431c2f1c87be9d4cea66aa252bce3cbf9e0747d4abbc0557b35b298c7331381778311a251bac1b959541c918cec4b2145bc731da7190c7082fc890ae83678e8f5b956428d1d97a06012f1eec1bde103adc7d9d3e39875291c5f0c7023b";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }



    function test_GLYPH_SNARK_SP1_Plonk_Succeeds() public {
        bytes memory proof = hex"f32ee924f85a31f0dc0b25fa87e868a55d05cf13ba324b496c7d6f6d5752f4f4348f2c2d3bbf32b47c192ddbe5e89c44d211095070248c8862f0f482e35a5f91a76a33633e15462fd6d70bd20fae04fa86b84c5a85117c2f67188a0ab4606dc3abdaf98eca56fd4adc246a51a754caa56ebc174c094518fdca94014a333443a04cd6e46a39ec75453e3cbcb62304d39fcef4e3fddb6a1c3b81437b3049aef39443b5faceabc2ce9f4c56bc6b2d5b0099db6d37ca5b4ee6db9c7fa0cbb8c278845184dd17bd59eddfaa943f85e7a34f42002c2aef5e25a483d1847ee14cba035c";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }

    function test_GLYPH_SNARK_SP1_Plonk_MetaTamper_Fails() public {
        bytes memory proof = hex"f32ee924f85a31f0dc0b25fa87e868a55d05cf13ba324b496c7d6f6d5752f4f4348f2c2d3bbf32b47c192ddbe5e89c44d211095070248c8862f0f482e35a5f91a76a33633e15462fd6d70bd20fae04fa86b84c5a85117c2f67188a0ab4606dc3abdaf98eca56fd4adc246a51a754caa56ebc174c094518fdca94014a333443a04cd6e46a39ec75453e3cbcb62304d39fcef4e3fddb6a1c3b81437b3049aef39443b5faceabc2ce9f4c56bc6b2d5b0099db6d37ca5b4ee6db9c7fa0cbb8c278845184dd17bd59eddfaa943f85e7a34f42002c2aef5e25a483d1847ee14cba035c";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }

}
