// SPDX-License-Identifier: MIT
// AUTO-GENERATED by GLYPH Rust Prover - DO NOT EDIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "./GLYPHVerifier.sol";

contract GLYPH_IVC_Test is Test {
    address internal constant TARGET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function setUp() public {
        vm.chainId(31337);
        GLYPHVerifier impl = new GLYPHVerifier();
        vm.etch(TARGET, address(impl).code);
    }

    function test_GLYPH_IVC_BaseFold_Succeeds() public {
        bytes memory proof = hex"14b926fe9fb137968340b27ae68afb95b85729d788ea1fc4ce85bbb308b1672bdb4a902673492e0b0000000000000000ec0f72304b6b97cf9c302798843fef05702165bcfe14bc7ab8d6229e9ff04af3c3daa875c52f381d01f9eebd2e9a3bd7d4b79405ade4f8dbe77aecfbde60908018b4e8a265f41c4b63a656e02123e7041957d1bb361215db4b7d4ab4d79f7e10dad4cfde50138108f982196e7e52356a7e22dbe43642015eceed209864434e3cd70070067b0e511c71770a16370b691c3376eb6eec9a8e88f302e787a737e2735bd2a6b3708bfb32c5ec3bd82e1ec94e";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }

    function test_GLYPH_IVC_BaseFold_MetaTamper_Fails() public {
        bytes memory proof = hex"14b926fe9fb137968340b27ae68afb95b85729d788ea1fc4ce85bbb308b1672bdb4a902673492e0b0000000000000000ec0f72304b6b97cf9c302798843fef05702165bcfe14bc7ab8d6229e9ff04af3c3daa875c52f381d01f9eebd2e9a3bd7d4b79405ade4f8dbe77aecfbde60908018b4e8a265f41c4b63a656e02123e7041957d1bb361215db4b7d4ab4d79f7e10dad4cfde50138108f982196e7e52356a7e22dbe43642015eceed209864434e3cd70070067b0e511c71770a16370b691c3376eb6eec9a8e88f302e787a737e2735bd2a6b3708bfb32c5ec3bd82e1ec94e";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }

    function test_GLYPH_IVC_Nova_Succeeds() public {
        bytes memory proof = hex"4d6f25a1716f97e8815b32d113a675a62b1ab79d44cad66daf65fdd6cd38f77061c6b693e8a8f1830000000000000000bd4cdab5b13154edfff7efcaf855fdd5d88abecf63116bbee42db93046e76c712b5fd823f95203c662fdae9cc87c427b0476768024c050456bb385bd73412ffa8609eef8c18b39a88372c5a59adfe3c8a9feab35441a015c5dab2f39217b208df4b8762abfacb3b6f1d76e07df22342bede3940aab3f4af71ce7e5964bb43caee874af088b0ff419331e3ca8ca3138f6403ee02a78de270516e52ac18ad574c6038c4b8213243a63b2ff34b8f9488d6b";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }

    function test_GLYPH_IVC_Nova_MetaTamper_Fails() public {
        bytes memory proof = hex"4d6f25a1716f97e8815b32d113a675a62b1ab79d44cad66daf65fdd6cd38f77061c6b693e8a8f1830000000000000000bd4cdab5b13154edfff7efcaf855fdd5d88abecf63116bbee42db93046e76c712b5fd823f95203c662fdae9cc87c427b0476768024c050456bb385bd73412ffa8609eef8c18b39a88372c5a59adfe3c8a9feab35441a015c5dab2f39217b208df4b8762abfacb3b6f1d76e07df22342bede3940aab3f4af71ce7e5964bb43caee874af088b0ff419331e3ca8ca3138f6403ee02a78de270516e52ac18ad574c6038c4b8213243a63b2ff34b8f9488d6b";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }


    function test_GLYPH_IVC_HyperNova_Succeeds() public {
        bytes memory proof = hex"388e1a5cdbdd00131869f24e4cbefa3432a45e9a94e0d7baf8bfb2972ea51802e6c3ebc388a1a94b0000000000000000233d7068fc532d087208816fcf98ecb91f9316ba2ce0b0cb9cfd84d80c3a8b8a2a8b52a6d82560b91eab1b700ce54ff68d2881526f0608d5c42e9d1ad2556b1199d2e1fba9ede9c59476ef1eab818b3dd59fd5f4d5e6c70b15f2f20181d7f8091a9f42a0895065528ae5f560675ec90a456e2c55d99d30c5cb4d0cbe9595dff2bc8b8771b438dbc187281670dcd1a98020dc9115f5f4b7245fbc9ea9d5924c836d54081c8088d977655136f57230cf96";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }

    function test_GLYPH_IVC_HyperNova_MetaTamper_Fails() public {
        bytes memory proof = hex"388e1a5cdbdd00131869f24e4cbefa3432a45e9a94e0d7baf8bfb2972ea51802e6c3ebc388a1a94b0000000000000000233d7068fc532d087208816fcf98ecb91f9316ba2ce0b0cb9cfd84d80c3a8b8a2a8b52a6d82560b91eab1b700ce54ff68d2881526f0608d5c42e9d1ad2556b1199d2e1fba9ede9c59476ef1eab818b3dd59fd5f4d5e6c70b15f2f20181d7f8091a9f42a0895065528ae5f560675ec90a456e2c55d99d30c5cb4d0cbe9595dff2bc8b8771b438dbc187281670dcd1a98020dc9115f5f4b7245fbc9ea9d5924c836d54081c8088d977655136f57230cf96";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }

    function test_GLYPH_IVC_Sangria_Succeeds() public {
        bytes memory proof = hex"a743c5eb06d330cdc1955952b4789333252295d8276d60eff61a0aae28ea645a756a12dfd5b76a8e00000000000000002616894135db3222ddaa6d795eaf5b2c073d9aca63bdd5bd3e41ba8009ff15401da8b6ba0d05d0e48733fa8dad74c58eb1d0bf22a5c265ebffe8fe6cf77a2c7a08542907da05511167a518ee9f3909819fa7e97c8af4482fabaacefda35b91d5ac544708cface01272f1a7094f26a670411449615c5fbf3090eacdee5f9768ad83e51c9f303b086459054d1e3be360b8bf034c038a1b9f04eacb4322faa68ab60da897e24514403e11555a29a7f24d61";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }

    function test_GLYPH_IVC_Sangria_MetaTamper_Fails() public {
        bytes memory proof = hex"a743c5eb06d330cdc1955952b4789333252295d8276d60eff61a0aae28ea645a756a12dfd5b76a8e00000000000000002616894135db3222ddaa6d795eaf5b2c073d9aca63bdd5bd3e41ba8009ff15401da8b6ba0d05d0e48733fa8dad74c58eb1d0bf22a5c265ebffe8fe6cf77a2c7a08542907da05511167a518ee9f3909819fa7e97c8af4482fabaacefda35b91d5ac544708cface01272f1a7094f26a670411449615c5fbf3090eacdee5f9768ad83e51c9f303b086459054d1e3be360b8bf034c038a1b9f04eacb4322faa68ab60da897e24514403e11555a29a7f24d61";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }
}
