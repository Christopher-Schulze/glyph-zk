// SPDX-License-Identifier: MIT
// AUTO-GENERATED by GLYPH Rust Prover - DO NOT EDIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "./GLYPHVerifier.sol";

contract GLYPH_HASH_Test is Test {
    address internal constant TARGET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function setUp() public {
        vm.chainId(31337);
        GLYPHVerifier impl = new GLYPHVerifier();
        vm.etch(TARGET, address(impl).code);
    }

    function test_GLYPH_HASH_Succeeds() public {
        bytes memory proof = hex"c8a98f16199b249639b436a79fc28b31e4131aa3ffc9a1552bcff6a2255c552489691d3f89ce472100000000000000004da76d92dfe5d4b0f287fe917f2697328c1aba0cc2effceee958b0ee6d2d2087e116ef2977bda58465003eb90484f76e3aec411eaa60c14d3f35af80218dfd3322e28ed86773567db5493e4a18390a51bcb81bc886460ced1a5a63f5c39f9250529df501be3e322651d02ca38104cb0bc31878850170f726af1a8a0d16d4b7804c6b09381f9d261899cf18f1b96cb2db573595c5c02fbbabed811d1f78c2337c3dc6ce52c2e7d255eebc0c186dd5a096";
        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }

    function test_GLYPH_HASH_MetaTamper_Fails() public {
        bytes memory proof = hex"c8a98f16199b249639b436a79fc28b31e4131aa3ffc9a1552bcff6a2255c552489691d3f89ce472100000000000000004da76d92dfe5d4b0f287fe917f2697328c1aba0cc2effceee958b0ee6d2d2087e116ef2977bda58465003eb90484f76e3aec411eaa60c14d3f35af80218dfd3322e28ed86773567db5493e4a18390a51bcb81bc886460ced1a5a63f5c39f9250529df501be3e322651d02ca38104cb0bc31878850170f726af1a8a0d16d4b7804c6b09381f9d261899cf18f1b96cb2db573595c5c02fbbabed811d1f78c2337c3dc6ce52c2e7d255eebc0c186dd5a096";
        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }

    function test_GLYPH_HASH_Digest_Matches() public pure {
        bytes32 lhs = 0x61479f900c15b71028d6d2d3b0b7d3d54ad296b90baba672d3879ba31e681bad;
        bytes32 rhs = 0x124984fee2c5d17d52762fa5ba52db97d6b626c150b3b5e974e0b06ba925bd5e;
        bytes32 expected = 0x6c901d72ee6d5174d1621e1031f809fa733077e69661f9b4340f9313c7b90704;
        bytes32 computed = keccak256(abi.encodePacked(lhs, rhs));
        assertEq(computed, expected, "keccak merge digest");
    }
}
