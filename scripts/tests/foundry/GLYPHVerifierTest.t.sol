// SPDX-License-Identifier: MIT
// AUTO-GENERATED by GLYPH Rust Prover - DO NOT EDIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "./GLYPHVerifier.sol";

/**
 * @title GLYPHVerifierTest
 * @notice Packed calldata verification vectors.
 *
 * Note: Packed-128 has no distinct truncated payload. The truncated vector is
 * intentionally identical to full and still exercises the same on-chain path.
 */
contract GLYPHVerifierTest is Test {
    address internal constant TARGET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function setUp() public {
        vm.chainId(31337);

        GLYPHVerifier impl = new GLYPHVerifier();
        vm.etch(TARGET, address(impl).code);
    }

    function test_GLYPHVerifier_VerifyPacked_Bound_Full_Succeeds() public {
        bytes memory proof = hex"746142a8f1263f051ce991584d9c265d60ef8ea046695a348fdf3546c13dd5d50000000000000000000000000000007b11d044492543d869c3f780db80b2dd069713a0d517f929c889cca1a6c9bc42819cf27acf5fb28ff986946ed74d538faa6e2b11c84328e933320b82aa17defc5eb1bde521081278f800290add5831e5cb3f919bc79a4c498368da01772018140051cac04eab644b3e6b637b33d3df05509ea1a53a59043175fd9c167bf08e5137ee83b450cbde3f2471f1ee2fe4c26fe50e81fbcbf77318461a1cb4ea42c994d2cd4c14ccbfa7db429ec751ed566610c0";

        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "bound full verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }

    function test_GLYPHVerifier_VerifyPacked_Bound_Truncated_Succeeds() public {
        bytes memory proof = hex"746142a8f1263f051ce991584d9c265d60ef8ea046695a348fdf3546c13dd5d50000000000000000000000000000007b11d044492543d869c3f780db80b2dd069713a0d517f929c889cca1a6c9bc42819cf27acf5fb28ff986946ed74d538faa6e2b11c84328e933320b82aa17defc5eb1bde521081278f800290add5831e5cb3f919bc79a4c498368da01772018140051cac04eab644b3e6b637b33d3df05509ea1a53a59043175fd9c167bf08e5137ee83b450cbde3f2471f1ee2fe4c26fe50e81fbcbf77318461a1cb4ea42c994d2cd4c14ccbfa7db429ec751ed566610c0";

        (bool ok, bytes memory ret) = TARGET.call(proof);
        assertTrue(ok, "bound truncated verify should succeed");
        assertEq(abi.decode(ret, (uint256)), 1, "return value");
    }

    function test_GLYPHVerifier_VerifyPacked_Bound_MetaTamper_Fails() public {
        bytes memory proof = hex"746142a8f1263f051ce991584d9c265d60ef8ea046695a348fdf3546c13dd5d50000000000000000000000000000007b11d044492543d869c3f780db80b2dd069713a0d517f929c889cca1a6c9bc42819cf27acf5fb28ff986946ed74d538faa6e2b11c84328e933320b82aa17defc5eb1bde521081278f800290add5831e5cb3f919bc79a4c498368da01772018140051cac04eab644b3e6b637b33d3df05509ea1a53a59043175fd9c167bf08e5137ee83b450cbde3f2471f1ee2fe4c26fe50e81fbcbf77318461a1cb4ea42c994d2cd4c14ccbfa7db429ec751ed566610c0";

        proof[31] = bytes1(uint8(proof[31]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "meta tamper must revert");
    }

    function test_GLYPHVerifier_VerifyPacked_Bound_ClaimHighBits_Fails() public {
        bytes memory proof = hex"746142a8f1263f051ce991584d9c265d60ef8ea046695a348fdf3546c13dd5d50000000000000000000000000000007b11d044492543d869c3f780db80b2dd069713a0d517f929c889cca1a6c9bc42819cf27acf5fb28ff986946ed74d538faa6e2b11c84328e933320b82aa17defc5eb1bde521081278f800290add5831e5cb3f919bc79a4c498368da01772018140051cac04eab644b3e6b637b33d3df05509ea1a53a59043175fd9c167bf08e5137ee83b450cbde3f2471f1ee2fe4c26fe50e81fbcbf77318461a1cb4ea42c994d2cd4c14ccbfa7db429ec751ed566610c0";

        // Upper 128 bits of claim (byte 96..111) must be zero.
        proof[96] = bytes1(uint8(proof[96]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "claim high bits must revert");
    }

    function test_GLYPHVerifier_VerifyPacked_Bound_ClaimTamper_Fails() public {
        bytes memory proof = hex"746142a8f1263f051ce991584d9c265d60ef8ea046695a348fdf3546c13dd5d50000000000000000000000000000007b11d044492543d869c3f780db80b2dd069713a0d517f929c889cca1a6c9bc42819cf27acf5fb28ff986946ed74d538faa6e2b11c84328e933320b82aa17defc5eb1bde521081278f800290add5831e5cb3f919bc79a4c498368da01772018140051cac04eab644b3e6b637b33d3df05509ea1a53a59043175fd9c167bf08e5137ee83b450cbde3f2471f1ee2fe4c26fe50e81fbcbf77318461a1cb4ea42c994d2cd4c14ccbfa7db429ec751ed566610c0";

        proof[127] = bytes1(uint8(proof[127]) ^ 1);
        (bool ok, ) = TARGET.call(proof);
        assertFalse(ok, "claim tamper must revert");
    }
}
